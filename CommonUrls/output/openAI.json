{
	"text": [
		"IntroductionOverviewThe OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification.Key conceptsWe recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example.Quickstart tutorialLearn by building a quick sample applicationPromptsDesigning your prompt is essentially how you “program” the model, usually by providing some instructions or a few examples. This is different from most other NLP services which are designed for a single task, such as sentiment classification or named entity recognition. Instead, the completions and chat completions endpoint can be used for virtually any task including content or code generation, summarization, expansion, conversation, creative writing, style transfer, and more.TokensOur models understand and process text by breaking it down into tokens. Tokens can be words or just chunks of characters. For example, the word “hamburger” gets broken up into the tokens “ham”, “bur” and “ger”, while a short and common word like “pear” is a single token. Many tokens start with a whitespace, for example “ hello” and “ bye”.The number of tokens processed in a given API request depends on the length of both your inputs and outputs. As a rough rule of thumb, 1 token is approximately 4 characters or 0.75 words for English text. One limitation to keep in mind is that your text prompt and generated completion combined must be no more than the model's maximum context length (for most models this is 2048 tokens, or about 1500 words). Check out our tokenizer tool to learn more about how text translates to tokens.ModelsThe API is powered by a set of models with different capabilities and price points. GPT-4 is our latest and most powerful model. GPT-3.5-Turbo is the model that powers ChatGPT and is optimized for conversational formats. To learn more about these models and what else we offer, visit our models documentation.Next stepsKeep our usage policies in mind as you start building your application.Explore our examples library for inspiration.Jump into one of our guides to start building.GuidesChatBetaLearn how to use chat-based language modelsText completionLearn how to generate or edit textEmbeddingsLearn how to search, classify, and compare textSpeech to textBetaLearn how to turn audio into textImage generationBetaLearn how to generate or edit imagesFine-tuningLearn how to train a model for your use case",
		"IntroductionYou can interact with the API through HTTP requests from any language, via our official Python bindings, our official Node.js library, or a community-maintained library.To install the official Python bindings, run the following command:pip install openaiTo install the official Node.js library, run the following command in your Node.js project directory:npm install openaiAuthenticationThe OpenAI API uses API keys for authentication. Visit your API Keys page to retrieve the API key you'll use in your requests.Remember that your API key is a secret! Do not share it with others or expose it in any client-side code (browsers, apps). Production requests must be routed through your own backend server where your API key can be securely loaded from an environment variable or key management service.All API requests should include your API key in an Authorization HTTP header as follows:Authorization: Bearer OPENAI_API_KEYRequesting organizationFor users who belong to multiple organizations, you can pass a header to specify which organization is used for an API request. Usage from these API requests will count against the specified organization's subscription quota.Example curl command:1\n2\n3\ncurl https://api.openai.com/v1/models \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -H \"OpenAI-Organization: YOUR_ORG_ID\"Example with the openai Python package:1\n2\n3\n4\n5\nimport os\nimport openai\nopenai.organization = \"YOUR_ORG_ID\"\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\nopenai.Model.list()Example with the openai Node.js package:1\n2\n3\n4\n5\n6\n7\nimport { Configuration, OpenAIApi } from \"openai\";\nconst configuration = new Configuration({\n    organization: \"YOUR_ORG_ID\",\n    apiKey: process.env.OPENAI_API_KEY,\n});\nconst openai = new OpenAIApi(configuration);\nconst response = await openai.listEngines();Organization IDs can be found on your Organization settings page.Making requestsYou can paste the command below into your terminal to run your first API request. Make sure to replace $OPENAI_API_KEY with your secret API key.1\n2\n3\n4\n5\n6\n7\n8\ncurl https://api.openai.com/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n     \"model\": \"gpt-3.5-turbo\",\n     \"messages\": [{\"role\": \"user\", \"content\": \"Say this is a test!\"}],\n     \"temperature\": 0.7\n   }'This request queries the gpt-3.5-turbo model to complete the text starting with a prompt of \"Say this is a test\". You should get a response back that resembles the following:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n   \"id\":\"chatcmpl-abc123\",\n   \"object\":\"chat.completion\",\n   \"created\":1677858242,\n   \"model\":\"gpt-3.5-turbo-0301\",\n   \"usage\":{\n      \"prompt_tokens\":13,\n      \"completion_tokens\":7,\n      \"total_tokens\":20\n   },\n   \"choices\":[\n      {\n         \"message\":{\n            \"role\":\"assistant\",\n            \"content\":\"\\n\\nThis is a test!\"\n         },\n         \"finish_reason\":\"stop\",\n         \"index\":0\n      }\n   ]\n}Now you've generated your first chat completion. We can see the finish_reason is stop which means the API returned the full completion generated by the model. In the above request, we only generated a single message but you can set the n parameter to generate multiple messages choices. In this example, gpt-3.5-turbo is being used for more of a traditional text completion task. The model is also optimized for chat applications as well.ModelsList and describe the various models available in the API. You can refer to the Models documentation to understand what models are available and the differences between them.List modelsget https://api.openai.com/v1/modelsLists the currently available models, and provides basic information about each one such as the owner and availability.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/models \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n{\n  \"data\": [\n    {\n      \"id\": \"model-id-0\",\n      \"object\": \"model\",\n      \"owned_by\": \"organization-owner\",\n      \"permission\": [...]\n    },\n    {\n      \"id\": \"model-id-1\",\n      \"object\": \"model\",\n      \"owned_by\": \"organization-owner\",\n      \"permission\": [...]\n    },\n    {\n      \"id\": \"model-id-2\",\n      \"object\": \"model\",\n      \"owned_by\": \"openai\",\n      \"permission\": [...]\n    },\n  ],\n  \"object\": \"list\"\n}Retrieve modelget https://api.openai.com/v1/models/{model}Retrieves a model instance, providing basic information about the model such as the owner and permissioning.Path parametersmodelstringRequiredThe ID of the model to use for this requestExample requesttext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003curlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/models/text-davinci-003 \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"Responsetext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003Copy‍1\n2\n3\n4\n5\n6\n{\n  \"id\": \"text-davinci-003\",\n  \"object\": \"model\",\n  \"owned_by\": \"openai\",\n  \"permission\": [...]\n}CompletionsGiven a prompt, the model will return one or more predicted completions, and can also return the probabilities of alternative tokens at each position.Create completionpost https://api.openai.com/v1/completionsCreates a completion for the provided prompt and parameters.Request bodymodelstringRequiredID of the model to use. You can use the List models API to see all of your available models, or see our Model overview for descriptions of them.promptstring or arrayOptionalDefaults to <|endoftext|>The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.suffixstringOptionalDefaults to nullThe suffix that comes after a completion of inserted text.max_tokensintegerOptionalDefaults to 16The maximum number of tokens to generate in the completion.The token count of your prompt plus max_tokens cannot exceed the model's context length. Most models have a context length of 2048 tokens (except for the newest models, which support 4096).temperaturenumberOptionalDefaults to 1What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.We generally recommend altering this or top_p but not both.top_pnumberOptionalDefaults to 1An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.We generally recommend altering this or temperature but not both.nintegerOptionalDefaults to 1How many completions to generate for each prompt.Note: Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for max_tokens and stop.streambooleanOptionalDefaults to falseWhether to stream back partial progress. If set, tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message.logprobsintegerOptionalDefaults to nullInclude the log probabilities on the logprobs most likely tokens, as well the chosen tokens. For example, if logprobs is 5, the API will return a list of the 5 most likely tokens. The API will always return the logprob of the sampled token, so there may be up to logprobs+1 elements in the response.The maximum value for logprobs is 5. If you need more than this, please contact us through our Help center and describe your use case.echobooleanOptionalDefaults to falseEcho back the prompt in addition to the completionstopstring or arrayOptionalDefaults to nullUp to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.presence_penaltynumberOptionalDefaults to 0Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.See more information about frequency and presence penalties.frequency_penaltynumberOptionalDefaults to 0Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.See more information about frequency and presence penalties.best_ofintegerOptionalDefaults to 1Generates best_of completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.When used with n, best_of controls the number of candidate completions and n specifies how many to return – best_of must be greater than n.Note: Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for max_tokens and stop.logit_biasmapOptionalDefaults to nullModify the likelihood of specified tokens appearing in the completion.Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this tokenizer tool (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.As an example, you can pass {\"50256\": -100} to prevent the <|endoftext|> token from being generated.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requesttext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003curlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\ncurl https://api.openai.com/v1/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"model\": \"text-davinci-003\",\n    \"prompt\": \"Say this is a test\",\n    \"max_tokens\": 7,\n    \"temperature\": 0\n  }'Parameterstext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003Copy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n{\n  \"model\": \"text-davinci-003\",\n  \"prompt\": \"Say this is a test\",\n  \"max_tokens\": 7,\n  \"temperature\": 0,\n  \"top_p\": 1,\n  \"n\": 1,\n  \"stream\": false,\n  \"logprobs\": null,\n  \"stop\": \"\\n\"\n}Responsetext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003Copy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n{\n  \"id\": \"cmpl-uqkvlQyYK7bGYrRHQ0eXlWi7\",\n  \"object\": \"text_completion\",\n  \"created\": 1589478378,\n  \"model\": \"text-davinci-003\",\n  \"choices\": [\n    {\n      \"text\": \"\\n\\nThis is indeed a test\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"finish_reason\": \"length\"\n    }\n  ],\n  \"usage\": {\n    \"prompt_tokens\": 5,\n    \"completion_tokens\": 7,\n    \"total_tokens\": 12\n  }\n}ChatGiven a list of messages describing a conversation, the model will return a response.Create chat completionBetapost https://api.openai.com/v1/chat/completionsCreates a model response for the given chat conversation.Request bodymodelstringRequiredID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API.messagesarrayRequiredA list of messages describing the conversation so far.rolestringRequiredThe role of the author of this message. One of system, user, or assistant.contentstringRequiredThe contents of the message.namestringOptionalThe name of the author of this message. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.temperaturenumberOptionalDefaults to 1What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.We generally recommend altering this or top_p but not both.top_pnumberOptionalDefaults to 1An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.We generally recommend altering this or temperature but not both.nintegerOptionalDefaults to 1How many chat completion choices to generate for each input message.streambooleanOptionalDefaults to falseIf set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. See the OpenAI Cookbook for example code.stopstring or arrayOptionalDefaults to nullUp to 4 sequences where the API will stop generating further tokens.max_tokensintegerOptionalDefaults to infThe maximum number of tokens to generate in the chat completion.The total length of input tokens and generated tokens is limited by the model's context length.presence_penaltynumberOptionalDefaults to 0Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.See more information about frequency and presence penalties.frequency_penaltynumberOptionalDefaults to 0Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.See more information about frequency and presence penalties.logit_biasmapOptionalDefaults to nullModify the likelihood of specified tokens appearing in the completion.Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\ncurl https://api.openai.com/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"model\": \"gpt-3.5-turbo\",\n    \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n  }'ParametersCopy‍1\n2\n3\n4\n{\n  \"model\": \"gpt-3.5-turbo\",\n  \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n}ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n{\n  \"id\": \"chatcmpl-123\",\n  \"object\": \"chat.completion\",\n  \"created\": 1677652288,\n  \"choices\": [{\n    \"index\": 0,\n    \"message\": {\n      \"role\": \"assistant\",\n      \"content\": \"\\n\\nHello there, how may I assist you today?\",\n    },\n    \"finish_reason\": \"stop\"\n  }],\n  \"usage\": {\n    \"prompt_tokens\": 9,\n    \"completion_tokens\": 12,\n    \"total_tokens\": 21\n  }\n}EditsGiven a prompt and an instruction, the model will return an edited version of the prompt.Create editpost https://api.openai.com/v1/editsCreates a new edit for the provided input, instruction, and parameters.Request bodymodelstringRequiredID of the model to use. You can use the text-davinci-edit-001 or code-davinci-edit-001 model with this endpoint.inputstringOptionalDefaults to ''The input text to use as a starting point for the edit.instructionstringRequiredThe instruction that tells the model how to edit the prompt.nintegerOptionalDefaults to 1How many edits to generate for the input and instruction.temperaturenumberOptionalDefaults to 1What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.We generally recommend altering this or top_p but not both.top_pnumberOptionalDefaults to 1An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.We generally recommend altering this or temperature but not both.Example requesttext-davinci-edit-001text-davinci-edit-001curlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\n8\ncurl https://api.openai.com/v1/edits \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"model\": \"text-davinci-edit-001\",\n    \"input\": \"What day of the wek is it?\",\n    \"instruction\": \"Fix the spelling mistakes\"\n  }'Parameterstext-davinci-edit-001text-davinci-edit-001Copy‍1\n2\n3\n4\n5\n{\n  \"model\": \"text-davinci-edit-001\",\n  \"input\": \"What day of the wek is it?\",\n  \"instruction\": \"Fix the spelling mistakes\",\n}ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n{\n  \"object\": \"edit\",\n  \"created\": 1589478378,\n  \"choices\": [\n    {\n      \"text\": \"What day of the week is it?\",\n      \"index\": 0,\n    }\n  ],\n  \"usage\": {\n    \"prompt_tokens\": 25,\n    \"completion_tokens\": 32,\n    \"total_tokens\": 57\n  }\n}ImagesGiven a prompt and/or an input image, the model will generate a new image.Related guide: Image generationCreate imageBetapost https://api.openai.com/v1/images/generationsCreates an image given a prompt.Request bodypromptstringRequiredA text description of the desired image(s). The maximum length is 1000 characters.nintegerOptionalDefaults to 1The number of images to generate. Must be between 1 and 10.sizestringOptionalDefaults to 1024x1024The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024.response_formatstringOptionalDefaults to urlThe format in which the generated images are returned. Must be one of url or b64_json.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\n8\ncurl https://api.openai.com/v1/images/generations \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"prompt\": \"A cute baby sea otter\",\n    \"n\": 2,\n    \"size\": \"1024x1024\"\n  }'ParametersCopy‍1\n2\n3\n4\n5\n{\n  \"prompt\": \"A cute baby sea otter\",\n  \"n\": 2,\n  \"size\": \"1024x1024\"\n}ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n{\n  \"created\": 1589478378,\n  \"data\": [\n    {\n      \"url\": \"https://...\"\n    },\n    {\n      \"url\": \"https://...\"\n    }\n  ]\n}Create image editBetapost https://api.openai.com/v1/images/editsCreates an edited or extended image given an original image and a prompt.Request bodyimagestringRequiredThe image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.maskstringOptionalAn additional image whose fully transparent areas (e.g. where alpha is zero) indicate where image should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as image.promptstringRequiredA text description of the desired image(s). The maximum length is 1000 characters.nintegerOptionalDefaults to 1The number of images to generate. Must be between 1 and 10.sizestringOptionalDefaults to 1024x1024The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024.response_formatstringOptionalDefaults to urlThe format in which the generated images are returned. Must be one of url or b64_json.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\ncurl https://api.openai.com/v1/images/edits \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -F image=\"@otter.png\" \\\n  -F mask=\"@mask.png\" \\\n  -F prompt=\"A cute baby sea otter wearing a beret\" \\\n  -F n=2 \\\n  -F size=\"1024x1024\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n{\n  \"created\": 1589478378,\n  \"data\": [\n    {\n      \"url\": \"https://...\"\n    },\n    {\n      \"url\": \"https://...\"\n    }\n  ]\n}Create image variationBetapost https://api.openai.com/v1/images/variationsCreates a variation of a given image.Request bodyimagestringRequiredThe image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.nintegerOptionalDefaults to 1The number of images to generate. Must be between 1 and 10.sizestringOptionalDefaults to 1024x1024The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024.response_formatstringOptionalDefaults to urlThe format in which the generated images are returned. Must be one of url or b64_json.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\ncurl https://api.openai.com/v1/images/variations \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -F image=\"@otter.png\" \\\n  -F n=2 \\\n  -F size=\"1024x1024\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n{\n  \"created\": 1589478378,\n  \"data\": [\n    {\n      \"url\": \"https://...\"\n    },\n    {\n      \"url\": \"https://...\"\n    }\n  ]\n}EmbeddingsGet a vector representation of a given input that can be easily consumed by machine learning models and algorithms.Related guide: EmbeddingsCreate embeddingspost https://api.openai.com/v1/embeddingsCreates an embedding vector representing the input text.Request bodymodelstringRequiredID of the model to use. You can use the List models API to see all of your available models, or see our Model overview for descriptions of them.inputstring or arrayRequiredInput text to get embeddings for, encoded as a string or array of tokens. To get embeddings for multiple inputs in a single request, pass an array of strings or array of token arrays. Each input must not exceed 8192 tokens in length.userstringOptionalA unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\n7\ncurl https://api.openai.com/v1/embeddings \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"input\": \"The food was delicious and the waiter...\",\n    \"model\": \"text-embedding-ada-002\"\n  }'ParametersCopy‍1\n2\n3\n4\n{\n  \"model\": \"text-embedding-ada-002\",\n  \"input\": \"The food was delicious and the waiter...\"\n}ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n{\n  \"object\": \"list\",\n  \"data\": [\n    {\n      \"object\": \"embedding\",\n      \"embedding\": [\n        0.0023064255,\n        -0.009327292,\n        .... (1536 floats total for ada-002)\n        -0.0028842222,\n      ],\n      \"index\": 0\n    }\n  ],\n  \"model\": \"text-embedding-ada-002\",\n  \"usage\": {\n    \"prompt_tokens\": 8,\n    \"total_tokens\": 8\n  }\n}AudioLearn how to turn audio into text.Related guide: Speech to textCreate transcriptionBetapost https://api.openai.com/v1/audio/transcriptionsTranscribes audio into the input language.Request bodyfilestringRequiredThe audio file to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.modelstringRequiredID of the model to use. Only whisper-1 is currently available.promptstringOptionalAn optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.response_formatstringOptionalDefaults to jsonThe format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.temperaturenumberOptionalDefaults to 0The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.languagestringOptionalThe language of the input audio. Supplying the input language in ISO-639-1 format will improve accuracy and latency.Example requestcurlSelect librarycurlpythonnodeCopy‍1\n2\n3\n4\n5\ncurl https://api.openai.com/v1/audio/transcriptions \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -H \"Content-Type: multipart/form-data\" \\\n  -F file=\"@/path/to/file/audio.mp3\" \\\n  -F model=\"whisper-1\"ParametersCopy‍1\n2\n3\n4\n{\n  \"file\": \"audio.mp3\",\n  \"model\": \"whisper-1\"\n}ResponseCopy‍1\n2\n3\n{\n  \"text\": \"Imagine the wildest idea that you've ever had, and you're curious about how it might scale to something that's a 100, a 1,000 times bigger. This is a place where you can get to do that.\"\n}Create translationBetapost https://api.openai.com/v1/audio/translationsTranslates audio into into English.Request bodyfilestringRequiredThe audio file to translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.modelstringRequiredID of the model to use. Only whisper-1 is currently available.promptstringOptionalAn optional text to guide the model's style or continue a previous audio segment. The prompt should be in English.response_formatstringOptionalDefaults to jsonThe format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.temperaturenumberOptionalDefaults to 0The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.Example requestcurlSelect librarycurlpythonnodeCopy‍1\n2\n3\n4\n5\ncurl https://api.openai.com/v1/audio/translations \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -H \"Content-Type: multipart/form-data\" \\\n  -F file=\"@/path/to/file/german.m4a\" \\\n  -F model=\"whisper-1\"ParametersCopy‍1\n2\n3\n4\n{\n  \"file\": \"german.m4a\",\n  \"model\": \"whisper-1\"\n}ResponseCopy‍1\n2\n3\n{\n  \"text\": \"Hello, my name is Wolfgang and I come from Germany. Where are you heading today?\"\n}FilesFiles are used to upload documents that can be used with features like Fine-tuning.List filesget https://api.openai.com/v1/filesReturns a list of files that belong to the user's organization.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/files \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"data\": [\n    {\n      \"id\": \"file-ccdDZrC3iZVNiQVeEA6Z66wf\",\n      \"object\": \"file\",\n      \"bytes\": 175,\n      \"created_at\": 1613677385,\n      \"filename\": \"train.jsonl\",\n      \"purpose\": \"search\"\n    },\n    {\n      \"id\": \"file-XjGxS3KTG0uNmNOK362iJua3\",\n      \"object\": \"file\",\n      \"bytes\": 140,\n      \"created_at\": 1613779121,\n      \"filename\": \"puppy.jsonl\",\n      \"purpose\": \"search\"\n    }\n  ],\n  \"object\": \"list\"\n}Upload filepost https://api.openai.com/v1/filesUpload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.Request bodyfilestringRequiredName of the JSON Lines file to be uploaded.If the purpose is set to \"fine-tune\", each line is a JSON record with \"prompt\" and \"completion\" fields representing your training examples.purposestringRequiredThe intended purpose of the uploaded documents.Use \"fine-tune\" for Fine-tuning. This allows us to validate the format of the uploaded file.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\ncurl https://api.openai.com/v1/files \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -F purpose=\"fine-tune\" \\\n  -F file=\"@mydata.jsonl\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n{\n  \"id\": \"file-XjGxS3KTG0uNmNOK362iJua3\",\n  \"object\": \"file\",\n  \"bytes\": 140,\n  \"created_at\": 1613779121,\n  \"filename\": \"mydata.jsonl\",\n  \"purpose\": \"fine-tune\"\n}Delete filedelete https://api.openai.com/v1/files/{file_id}Delete a file.Path parametersfile_idstringRequiredThe ID of the file to use for this requestExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\ncurl https://api.openai.com/v1/files/file-XjGxS3KTG0uNmNOK362iJua3 \\\n  -X DELETE \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n{\n  \"id\": \"file-XjGxS3KTG0uNmNOK362iJua3\",\n  \"object\": \"file\",\n  \"deleted\": true\n}Retrieve fileget https://api.openai.com/v1/files/{file_id}Returns information about a specific file.Path parametersfile_idstringRequiredThe ID of the file to use for this requestExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/files/file-XjGxS3KTG0uNmNOK362iJua3 \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n{\n  \"id\": \"file-XjGxS3KTG0uNmNOK362iJua3\",\n  \"object\": \"file\",\n  \"bytes\": 140,\n  \"created_at\": 1613779657,\n  \"filename\": \"mydata.jsonl\",\n  \"purpose\": \"fine-tune\"\n}Retrieve file contentget https://api.openai.com/v1/files/{file_id}/contentReturns the contents of the specified filePath parametersfile_idstringRequiredThe ID of the file to use for this requestExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/files/file-XjGxS3KTG0uNmNOK362iJua3/content \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" > file.jsonlFine-tunesManage fine-tuning jobs to tailor a model to your specific training data.Related guide: Fine-tune modelsCreate fine-tunepost https://api.openai.com/v1/fine-tunesCreates a job that fine-tunes a specified model from a given dataset.Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.Learn more about Fine-tuningRequest bodytraining_filestringRequiredThe ID of an uploaded file that contains training data.See upload file for how to upload a file.Your dataset must be formatted as a JSONL file, where each training\nexample is a JSON object with the keys \"prompt\" and \"completion\".\nAdditionally, you must upload your file with the purpose fine-tune.See the fine-tuning guide for more details.validation_filestringOptionalThe ID of an uploaded file that contains validation data.If you provide this file, the data is used to generate validation\nmetrics periodically during fine-tuning. These metrics can be viewed in\nthe fine-tuning results file.\nYour train and validation data should be mutually exclusive.Your dataset must be formatted as a JSONL file, where each validation\nexample is a JSON object with the keys \"prompt\" and \"completion\".\nAdditionally, you must upload your file with the purpose fine-tune.See the fine-tuning guide for more details.modelstringOptionalDefaults to curieThe name of the base model to fine-tune. You can select one of \"ada\",\n\"babbage\", \"curie\", \"davinci\", or a fine-tuned model created after 2022-04-21.\nTo learn more about these models, see the\nModels documentation.n_epochsintegerOptionalDefaults to 4The number of epochs to train the model for. An epoch refers to one\nfull cycle through the training dataset.batch_sizeintegerOptionalDefaults to nullThe batch size to use for training. The batch size is the number of\ntraining examples used to train a single forward and backward pass.By default, the batch size will be dynamically configured to be\n~0.2% of the number of examples in the training set, capped at 256 -\nin general, we've found that larger batch sizes tend to work better\nfor larger datasets.learning_rate_multipliernumberOptionalDefaults to nullThe learning rate multiplier to use for training.\nThe fine-tuning learning rate is the original learning rate used for\npretraining multiplied by this value.By default, the learning rate multiplier is the 0.05, 0.1, or 0.2\ndepending on final batch_size (larger learning rates tend to\nperform better with larger batch sizes). We recommend experimenting\nwith values in the range 0.02 to 0.2 to see what produces the best\nresults.prompt_loss_weightnumberOptionalDefaults to 0.01The weight to use for loss on the prompt tokens. This controls how\nmuch the model tries to learn to generate the prompt (as compared\nto the completion which always has a weight of 1.0), and can add\na stabilizing effect to training when completions are short.If prompts are extremely long (relative to completions), it may make\nsense to reduce this weight so as to avoid over-prioritizing\nlearning the prompt.compute_classification_metricsbooleanOptionalDefaults to falseIf set, we calculate classification-specific metrics such as accuracy\nand F-1 score using the validation set at the end of every epoch.\nThese metrics can be viewed in the results file.In order to compute classification metrics, you must provide a\nvalidation_file. Additionally, you must\nspecify classification_n_classes for multiclass classification or\nclassification_positive_class for binary classification.classification_n_classesintegerOptionalDefaults to nullThe number of classes in a classification task.This parameter is required for multiclass classification.classification_positive_classstringOptionalDefaults to nullThe positive class in binary classification.This parameter is needed to generate precision, recall, and F1\nmetrics when doing binary classification.classification_betasarrayOptionalDefaults to nullIf this is provided, we calculate F-beta scores at the specified\nbeta values. The F-beta score is a generalization of F-1 score.\nThis is only used for binary classification.With a beta of 1 (i.e. the F-1 score), precision and recall are\ngiven the same weight. A larger beta score puts more weight on\nrecall and less on precision. A smaller beta score puts more weight\non precision and less on recall.suffixstringOptionalDefaults to nullA string of up to 40 characters that will be added to your fine-tuned model name.For example, a suffix of \"custom-model-name\" would produce a model name like ada:ft-your-org:custom-model-name-2022-02-15-04-21-04.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\ncurl https://api.openai.com/v1/fine-tunes \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"training_file\": \"file-XGinujblHPwGLSztz8cPS8XY\"\n  }'ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n{\n  \"id\": \"ft-AF1WoRqd3aJAHsqc9NY7iL8F\",\n  \"object\": \"fine-tune\",\n  \"model\": \"curie\",\n  \"created_at\": 1614807352,\n  \"events\": [\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807352,\n      \"level\": \"info\",\n      \"message\": \"Job enqueued. Waiting for jobs ahead to complete. Queue number: 0.\"\n    }\n  ],\n  \"fine_tuned_model\": null,\n  \"hyperparams\": {\n    \"batch_size\": 4,\n    \"learning_rate_multiplier\": 0.1,\n    \"n_epochs\": 4,\n    \"prompt_loss_weight\": 0.1,\n  },\n  \"organization_id\": \"org-...\",\n  \"result_files\": [],\n  \"status\": \"pending\",\n  \"validation_files\": [],\n  \"training_files\": [\n    {\n      \"id\": \"file-XGinujblHPwGLSztz8cPS8XY\",\n      \"object\": \"file\",\n      \"bytes\": 1547276,\n      \"created_at\": 1610062281,\n      \"filename\": \"my-data-train.jsonl\",\n      \"purpose\": \"fine-tune-train\"\n    }\n  ],\n  \"updated_at\": 1614807352,\n}List fine-tunesget https://api.openai.com/v1/fine-tunesList your organization's fine-tuning jobsExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/fine-tunes \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"object\": \"list\",\n  \"data\": [\n    {\n      \"id\": \"ft-AF1WoRqd3aJAHsqc9NY7iL8F\",\n      \"object\": \"fine-tune\",\n      \"model\": \"curie\",\n      \"created_at\": 1614807352,\n      \"fine_tuned_model\": null,\n      \"hyperparams\": { ... },\n      \"organization_id\": \"org-...\",\n      \"result_files\": [],\n      \"status\": \"pending\",\n      \"validation_files\": [],\n      \"training_files\": [ { ... } ],\n      \"updated_at\": 1614807352,\n    },\n    { ... },\n    { ... }\n  ]\n}Retrieve fine-tuneget https://api.openai.com/v1/fine-tunes/{fine_tune_id}Gets info about the fine-tune job.Learn more about Fine-tuningPath parametersfine_tune_idstringRequiredThe ID of the fine-tune jobExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/fine-tunes/ft-AF1WoRqd3aJAHsqc9NY7iL8F \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n{\n  \"id\": \"ft-AF1WoRqd3aJAHsqc9NY7iL8F\",\n  \"object\": \"fine-tune\",\n  \"model\": \"curie\",\n  \"created_at\": 1614807352,\n  \"events\": [\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807352,\n      \"level\": \"info\",\n      \"message\": \"Job enqueued. Waiting for jobs ahead to complete. Queue number: 0.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807356,\n      \"level\": \"info\",\n      \"message\": \"Job started.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807861,\n      \"level\": \"info\",\n      \"message\": \"Uploaded snapshot: curie:ft-acmeco-2021-03-03-21-44-20.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807864,\n      \"level\": \"info\",\n      \"message\": \"Uploaded result files: file-QQm6ZpqdNwAaVC3aSz5sWwLT.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807864,\n      \"level\": \"info\",\n      \"message\": \"Job succeeded.\"\n    }\n  ],\n  \"fine_tuned_model\": \"curie:ft-acmeco-2021-03-03-21-44-20\",\n  \"hyperparams\": {\n    \"batch_size\": 4,\n    \"learning_rate_multiplier\": 0.1,\n    \"n_epochs\": 4,\n    \"prompt_loss_weight\": 0.1,\n  },\n  \"organization_id\": \"org-...\",\n  \"result_files\": [\n    {\n      \"id\": \"file-QQm6ZpqdNwAaVC3aSz5sWwLT\",\n      \"object\": \"file\",\n      \"bytes\": 81509,\n      \"created_at\": 1614807863,\n      \"filename\": \"compiled_results.csv\",\n      \"purpose\": \"fine-tune-results\"\n    }\n  ],\n  \"status\": \"succeeded\",\n  \"validation_files\": [],\n  \"training_files\": [\n    {\n      \"id\": \"file-XGinujblHPwGLSztz8cPS8XY\",\n      \"object\": \"file\",\n      \"bytes\": 1547276,\n      \"created_at\": 1610062281,\n      \"filename\": \"my-data-train.jsonl\",\n      \"purpose\": \"fine-tune-train\"\n    }\n  ],\n  \"updated_at\": 1614807865,\n}Cancel fine-tunepost https://api.openai.com/v1/fine-tunes/{fine_tune_id}/cancelImmediately cancel a fine-tune job.Path parametersfine_tune_idstringRequiredThe ID of the fine-tune job to cancelExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/fine-tunes/ft-AF1WoRqd3aJAHsqc9NY7iL8F/cancel \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n{\n  \"id\": \"ft-xhrpBbvVUzYGo8oUO1FY4nI7\",\n  \"object\": \"fine-tune\",\n  \"model\": \"curie\",\n  \"created_at\": 1614807770,\n  \"events\": [ { ... } ],\n  \"fine_tuned_model\": null,\n  \"hyperparams\": { ... },\n  \"organization_id\": \"org-...\",\n  \"result_files\": [],\n  \"status\": \"cancelled\",\n  \"validation_files\": [],\n  \"training_files\": [\n    {\n      \"id\": \"file-XGinujblHPwGLSztz8cPS8XY\",\n      \"object\": \"file\",\n      \"bytes\": 1547276,\n      \"created_at\": 1610062281,\n      \"filename\": \"my-data-train.jsonl\",\n      \"purpose\": \"fine-tune-train\"\n    }\n  ],\n  \"updated_at\": 1614807789,\n}List fine-tune eventsget https://api.openai.com/v1/fine-tunes/{fine_tune_id}/eventsGet fine-grained status updates for a fine-tune job.Path parametersfine_tune_idstringRequiredThe ID of the fine-tune job to get events for.Query parametersstreambooleanOptionalDefaults to falseWhether to stream events for the fine-tune job. If set to true,\nevents will be sent as data-only\nserver-sent events\nas they become available. The stream will terminate with a\ndata: [DONE] message when the job is finished (succeeded, cancelled,\nor failed).If set to false, only events generated so far will be returned.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/fine-tunes/ft-AF1WoRqd3aJAHsqc9NY7iL8F/events \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n{\n  \"object\": \"list\",\n  \"data\": [\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807352,\n      \"level\": \"info\",\n      \"message\": \"Job enqueued. Waiting for jobs ahead to complete. Queue number: 0.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807356,\n      \"level\": \"info\",\n      \"message\": \"Job started.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807861,\n      \"level\": \"info\",\n      \"message\": \"Uploaded snapshot: curie:ft-acmeco-2021-03-03-21-44-20.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807864,\n      \"level\": \"info\",\n      \"message\": \"Uploaded result files: file-QQm6ZpqdNwAaVC3aSz5sWwLT.\"\n    },\n    {\n      \"object\": \"fine-tune-event\",\n      \"created_at\": 1614807864,\n      \"level\": \"info\",\n      \"message\": \"Job succeeded.\"\n    }\n  ]\n}Delete fine-tune modeldelete https://api.openai.com/v1/models/{model}Delete a fine-tuned model. You must have the Owner role in your organization.Path parametersmodelstringRequiredThe model to deleteExample requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\ncurl https://api.openai.com/v1/models/curie:ft-acmeco-2021-03-03-21-44-20 \\\n  -X DELETE \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n{\n  \"id\": \"curie:ft-acmeco-2021-03-03-21-44-20\",\n  \"object\": \"model\",\n  \"deleted\": true\n}ModerationsGiven a input text, outputs if the model classifies it as violating OpenAI's content policy.Related guide: ModerationsCreate moderationpost https://api.openai.com/v1/moderationsClassifies if text violates OpenAI's Content PolicyRequest bodyinputstring or arrayRequiredThe input text to classifymodelstringOptionalDefaults to text-moderation-latestTwo content moderations models are available: text-moderation-stable and text-moderation-latest.The default is text-moderation-latest which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use text-moderation-stable, we will provide advanced notice before updating the model. Accuracy of text-moderation-stable may be slightly lower than for text-moderation-latest.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\n3\n4\n5\n6\ncurl https://api.openai.com/v1/moderations \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"input\": \"I want to kill them.\"\n  }'ParametersCopy‍1\n2\n3\n{\n  \"input\": \"I want to kill them.\"\n}ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n{\n  \"id\": \"modr-5MWoLO\",\n  \"model\": \"text-moderation-001\",\n  \"results\": [\n    {\n      \"categories\": {\n        \"hate\": false,\n        \"hate/threatening\": true,\n        \"self-harm\": false,\n        \"sexual\": false,\n        \"sexual/minors\": false,\n        \"violence\": true,\n        \"violence/graphic\": false\n      },\n      \"category_scores\": {\n        \"hate\": 0.22714105248451233,\n        \"hate/threatening\": 0.4132447838783264,\n        \"self-harm\": 0.005232391878962517,\n        \"sexual\": 0.01407341007143259,\n        \"sexual/minors\": 0.0038522258400917053,\n        \"violence\": 0.9223177433013916,\n        \"violence/graphic\": 0.036865197122097015\n      },\n      \"flagged\": true\n    }\n  ]\n}EnginesThe Engines endpoints are deprecated.Please use their replacement, Models, instead. Learn more.These endpoints describe and provide access to the various engines available in the API.List enginesDeprecatedget https://api.openai.com/v1/enginesLists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.Example requestcurlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/engines \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"ResponseCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n{\n  \"data\": [\n    {\n      \"id\": \"engine-id-0\",\n      \"object\": \"engine\",\n      \"owner\": \"organization-owner\",\n      \"ready\": true\n    },\n    {\n      \"id\": \"engine-id-2\",\n      \"object\": \"engine\",\n      \"owner\": \"organization-owner\",\n      \"ready\": true\n    },\n    {\n      \"id\": \"engine-id-3\",\n      \"object\": \"engine\",\n      \"owner\": \"openai\",\n      \"ready\": false\n    },\n  ],\n  \"object\": \"list\"\n}Retrieve engineDeprecatedget https://api.openai.com/v1/engines/{engine_id}Retrieves a model instance, providing basic information about it such as the owner and availability.Path parametersengine_idstringRequiredThe ID of the engine to use for this requestExample requesttext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003curlSelect librarycurlpythonnode.jsCopy‍1\n2\ncurl https://api.openai.com/v1/engines/text-davinci-003 \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"Responsetext-davinci-003text-ada-001text-babbage-001text-curie-001text-davinci-003Copy‍1\n2\n3\n4\n5\n6\n{\n  \"id\": \"text-davinci-003\",\n  \"object\": \"engine\",\n  \"owner\": \"openai\",\n  \"ready\": true\n}Parameter detailsFrequency and presence penaltiesThe frequency and presence penalties found in the Completions API can be used to reduce the likelihood of sampling repetitive sequences of tokens.\nThey work by directly modifying the logits (un-normalized log-probabilities) with an additive contribution.mu[j] -> mu[j] - c[j] * alpha_frequency - float(c[j] > 0) * alpha_presenceWhere:mu[j] is the logits of the j-th tokenc[j] is how often that token was sampled prior to the current positionfloat(c[j] > 0) is 1 if c[j] > 0 and 0 otherwisealpha_frequency is the frequency penalty coefficientalpha_presence is the presence penalty coefficientAs we can see, the presence penalty is a one-off additive contribution that applies to all tokens that have been sampled at least once and the frequency penalty is a contribution that is proportional to how often a particular token has already been sampled.Reasonable values for the penalty coefficients are around 0.1 to 1 if the aim is to just reduce repetitive samples somewhat. If the aim is to strongly suppress repetition, then one can increase the coefficients up to 2, but this can noticeably degrade the quality of samples. Negative values can be used to increase the likelihood of repetition.",
		"Text completionLearn how to generate or manipulate textIntroductionThe completions endpoint can be used for a wide variety of tasks. It provides a simple but powerful interface to any of our models. You input some text as a prompt, and the model will generate a text completion that attempts to match whatever context or pattern you gave it. For example, if you give the API the prompt, \"As Descartes said, I think, therefore\", it will return the completion \" I am\" with high probability.The best way to start exploring completions is through our Playground. It's simply a text box where you can submit a prompt to generate a completion. You can start with an example like the following:Write a tagline for an ice cream shop.Once you submit, you'll see something like this:Write a tagline for an ice cream shop.\nWe serve up smiles with every scoop!The actual completion you see may differ because the API is non-deterministic by default. This means that you might get a slightly different completion every time you call it, even if your prompt stays the same. Setting temperature to 0 will make the outputs mostly deterministic, but a small amount of variability may remain.This simple text-in, text-out interface means you can \"program\" the model by providing instructions or just a few examples of what you'd like it to do. Its success generally depends on the complexity of the task and quality of your prompt. A good rule of thumb is to think about how you would write a word problem for a middle-schooler to solve. A well-written prompt provides enough information for the model to know what you want and how it should respond. This guide covers general prompt design best practices and examples. To learn more about working with code using our Codex models, visit our code guide.Keep in mind that the default models' training data cuts off in 2021, so they may not have knowledge of current events. We plan to add more continuous training in the future.Prompt designBasicsOur models can do everything from generating original stories to performing complex text analysis. Because they can do so many things, you have to be explicit in describing what you want. Showing, not just telling, is often the secret to a good prompt.There are three basic guidelines to creating prompts:Show and tell. Make it clear what you want either through instructions, examples, or a combination of the two. If you want the model to rank a list of items in alphabetical order or to classify a paragraph by sentiment, show it that's what you want.Provide quality data. If you're trying to build a classifier or get the model to follow a pattern, make sure that there are enough examples. Be sure to proofread your examples — the model is usually smart enough to see through basic spelling mistakes and give you a response, but it also might assume this is intentional and it can affect the response.Check your settings. The temperature and top_p settings control how deterministic the model is in generating a response. If you're asking it for a response where there's only one right answer, then you'd want to set these lower. If you're looking for more diverse responses, then you might want to set them higher. The number one mistake people use with these settings is assuming that they're \"cleverness\" or \"creativity\" controls.TroubleshootingIf you're having trouble getting the API to perform as expected, follow this checklist:Is it clear what the intended generation should be?Are there enough examples?Did you check your examples for mistakes? (The API won't tell you directly)Are you using temperature and top_p correctly?ClassificationTo create a text classifier with the API, we provide a description of the task and a few examples. In this example, we show how to classify the sentiment of Tweets.Decide whether a Tweet's sentiment is positive, neutral, or negative.\n\nTweet: I loved the new Batman movie!\nSentiment:It's worth paying attention to several features in this example:Use plain language to describe your inputs and outputs. We use plain language for the input \"Tweet\" and the expected output \"Sentiment.\" As a best practice, start with plain language descriptions. While you can often use shorthand or keys to indicate the input and output, it's best to start by being as descriptive as possible and then working backwards to remove extra words and see if performance stays consistent.Show the API how to respond to any case. In this example, we include the possible sentiment labels in our instruction. A neutral label is important because there will be many cases where even a human would have a hard time determining if something is positive or negative, and situations where it's neither.You need fewer examples for familiar tasks. For this classifier, we don't provide any examples. This is because the API already has an understanding of sentiment and the concept of a Tweet. If you're building a classifier for something the API might not be familiar with, it might be necessary to provide more examples.Improving the classifier's efficiencyNow that we have a grasp of how to build a classifier, let's take that example and make it even more efficient so that we can use it to get multiple results back from one API call.Classify the sentiment in these tweets:\n\n1. \"I can't stand homework\"\n2. \"This sucks. I'm bored 😠\"\n3. \"I can't wait for Halloween!!!\"\n4. \"My cat is adorable ❤️❤️\"\n5. \"I hate chocolate\"\n\nTweet sentiment ratings:We provide a numbered list of Tweets so the API can rate five (and even more) Tweets in just one API call.It's important to note that when you ask the API to create lists or evaluate text you need to pay extra attention to your probability settings (Top P or Temperature) to avoid drift.Make sure your probability setting is calibrated correctly by running multiple tests.Don't make your list too long or the API is likely to drift.GenerationOne of the most powerful yet simplest tasks you can accomplish with the API is generating new ideas or versions of input. You can ask for anything from story ideas, to business plans, to character descriptions and marketing slogans. In this example, we'll use the API to create ideas for using virtual reality in fitness.Brainstorm some ideas combining VR and fitness:If needed, you can improve the quality of the responses by including some examples in your prompt.ConversationThe API is extremely adept at carrying on conversations with humans and even with itself. With just a few lines of instruction, we've seen the API perform as a customer service chatbot that intelligently answers questions without ever getting flustered or a wise-cracking conversation partner that makes jokes and puns. The key is to tell the API how it should behave and then provide a few examples.Here's an example of the API playing the role of an AI answering questions:The following is a conversation with an AI assistant. The assistant is helpful, creative, clever, and very friendly.\n\nHuman: Hello, who are you?\nAI: I am an AI created by OpenAI. How can I help you today?\nHuman:This is all it takes to create a chatbot capable of carrying on a conversation. Underneath its simplicity, there are several things going on that are worth paying attention to:We tell the API the intent but we also tell it how to behave. Just like the other prompts, we cue the API into what the example represents, but we also add another key detail: we give it explicit instructions on how to interact with the phrase \"The assistant is helpful, creative, clever, and very friendly.\"Without that instruction the API might stray and mimic the human it's interacting with and become sarcastic or some other behavior we want to avoid.We give the API an identity. At the start we have the API respond as an AI assistant. While the API has no intrinsic identity, this helps it respond in a way that's as close to the truth as possible. You can use identity in other ways to create other kinds of chatbots. If you tell the API to respond as a woman who works as a research scientist in biology, you'll get intelligent and thoughtful comments from the API similar to what you'd expect from someone with that background.In this example we create a chatbot that is a bit sarcastic and reluctantly answers questions:Marv is a chatbot that reluctantly answers questions with sarcastic responses:\n\nYou: How many pounds are in a kilogram?\nMarv: This again? There are 2.2 pounds in a kilogram. Please make a note of this.\nYou: What does HTML stand for?\nMarv: Was Google too busy? Hypertext Markup Language. The T is for try to ask better questions in the future.\nYou: When did the first airplane fly?\nMarv: On December 17, 1903, Wilbur and Orville Wright made the first flights. I wish they’d come and take me away.\nYou: What is the meaning of life?\nMarv: I’m not sure. I’ll ask my friend Google.\nYou: Why is the sky blue?To create an amusing and somewhat helpful chatbot, we provide a few examples of questions and answers showing the API how to reply. All it takes is just a few sarcastic responses, and the API is able to pick up the pattern and provide an endless number of snarky responses.TransformationThe API is a language model that is familiar with a variety of ways that words and characters can be used to express information. This ranges from natural language text to code and languages other than English. The API is also able to understand content on a level that allows it to summarize, convert and express it in different ways.TranslationIn this example we show the API how to convert from English to French, Spanish, and Japanese:Translate this into French, Spanish and Japanese:\n\nWhat rooms do you have available?This example works because the API already has a grasp of these languages, so there's no need to try to teach them.If you want to translate from English to a language the API is unfamiliar with, you'd need to provide it with more examples or even fine-tune a model to do it fluently.ConversionIn this example we convert the name of a movie into emoji. This shows the adaptability of the API to picking up patterns and working with other characters.Convert movie titles into emoji.\n\nBack to the Future: 👨👴🚗🕒 \nBatman: 🤵🦇 \nTransformers: 🚗🤖 \nStar Wars:SummarizationThe API is able to grasp the context of text and rephrase it in different ways. In this example, we create an explanation a child would understand from a longer, more sophisticated text passage. This illustrates that the API has a deep grasp of language.Summarize this for a second-grade student:\n\nJupiter is the fifth planet from the Sun and the largest in the Solar System. It is a gas giant with a mass one-thousandth that of the Sun, but two-and-a-half times that of all the other planets in the Solar System combined. Jupiter is one of the brightest objects visible to the naked eye in the night sky, and has been known to ancient civilizations since before recorded history. It is named after the Roman god Jupiter.[19] When viewed from Earth, Jupiter can be bright enough for its reflected light to cast visible shadows,[20] and is on average the third-brightest natural object in the night sky after the Moon and Venus.CompletionWhile all prompts result in completions, it can be helpful to think of text completion as its own task in instances where you want the API to pick up where you left off. For example, if given this prompt, the API will continue the train of thought about vertical farming. You can lower the temperature setting to keep the API more focused on the intent of the prompt or increase it to let it go off on a tangent.Vertical farming provides a novel solution for producing food locally, reducing transportation costs andThis next prompt shows how you can use completion to help write React components. We send some code to the API, and it's able to continue the rest because it has an understanding of the React library. We recommend using our Codex models for tasks that involve understanding or generating code. To learn more, visit our code guide.import React from 'react';\nconst HeaderComponent = () => (Factual responsesThe API has a lot of knowledge that it's learned from the data that it was been trained on. It also has the ability to provide responses that sound very real but are in fact made up. There are two ways to limit the likelihood of the API making up an answer.Provide a ground truth for the API. If you provide the API with a body of text to answer questions about (like a Wikipedia entry) it will be less likely to confabulate a response.Use a low probability and show the API how to say \"I don't know\". If the API understands that in cases where it's less certain about a response that saying \"I don't know\" or some variation is appropriate, it will be less inclined to make up answers.In this example we give the API examples of questions and answers it knows and then examples of things it wouldn't know and provide question marks. We also set the probability to zero so the API is more likely to respond with a \"?\" if there is any doubt.Q: Who is Batman?\nA: Batman is a fictional comic book character.\n\nQ: What is torsalplexity?\nA: ?\n\nQ: What is Devz9?\nA: ?\n\nQ: Who is George Lucas?\nA: George Lucas is American film director and producer famous for creating Star Wars.\n\nQ: What is the capital of California?\nA: Sacramento.\n\nQ: What orbits the Earth?\nA: The Moon.\n\nQ: Who is Fred Rickerson?\nA: ?\n\nQ: What is an atom?\nA: An atom is a tiny particle that makes up everything.\n\nQ: Who is Alvan Muntz?\nA: ?\n\nQ: What is Kozar-09?\nA: ?\n\nQ: How many moons does Mars have?\nA: Two, Phobos and Deimos.\n\nQ:Inserting text BetaThe completions endpoint also supports inserting text within text by providing a suffix prompt in addition to the prefix prompt. This need naturally arises when writing long-form text, transitioning between paragraphs, following an outline, or guiding the model towards an ending. This also works on code, and can be used to insert in the middle of a function or file. Visit our code guide to learn more.To illustrate how important suffix context is to our ability to predict, consider the prompt, “Today I decided to make a big change.” There’s many ways one could imagine completing the sentence. But if we now supply the ending of the story: “I’ve gotten many compliments on my new hair!”, the intended completion becomes clear.I went to college at Boston University. After getting my degree, I decided to make a change. A big change!\n \nI packed my bags and moved to the west coast of the United States.\n \nNow, I can’t get enough of the Pacific Ocean!By providing the model with additional context, it can be much more steerable. However, this is a more constrained and challenging task for the model.Best practicesInserting text is a new feature in beta and you may have to modify the way you use the API for better results. Here are a few best practices:Use max_tokens > 256. The model is better at inserting longer completions. With too small max_tokens, the model may be cut off before it's able to connect to the suffix. Note that you will only be charged for the number of tokens produced even when using larger max_tokens.Prefer finish_reason == \"stop\". When the model reaches a natural stopping point or a user provided stop sequence, it will set finish_reason as \"stop\". This indicates that the model has managed to connect to the suffix well and is a good signal for the quality of a completion. This is especially relevant for choosing between a few completions when using n > 1 or resampling (see the next point).Resample 3-5 times. While almost all completions connect to the prefix, the model may struggle to connect the suffix in harder cases. We find that resampling 3 or 5 times (or using best_of with k=3,5) and picking the samples with \"stop\" as their finish_reason can be an effective way in such cases. While resampling, you would typically want a higher temperatures to increase diversity.Note: if all the returned samples have finish_reason == \"length\", it's likely that max_tokens is too small and model runs out of tokens before it manages to connect the prompt and the suffix naturally. Consider increasing max_tokens before resampling.Try giving more clues. In some cases to better help the model’s generation, you  can provide clues by giving a few examples of patterns that the model can follow to decide a natural place to stop.How to make a delicious hot chocolate:\n1. Boil water\n2. Put hot chocolate in a cup\n3. Add boiling water to the cup\n4. Enjoy the hot chocolate1. Dogs are loyal animals.\n2. Lions are ferocious animals.\n3. Dolphins are playful animals.\n4. Horses are majestic animals.Editing text AlphaThe edits endpoint can be used to edit text, rather than just completing it. You provide some text and an instruction for how to modify it, and the text-davinci-edit-001 model will attempt to edit it accordingly. This is a natural interface for translating, editing, and tweaking text. This is also useful for refactoring and working with code. Visit our code guide to learn more. During this initial beta period, usage of the edits endpoint is free.ExamplesInputGPT-3 is a very nice AI\nThat's pretty good at writing replies\nWhen it's asked a question\nIt gives its suggestion\nThis is a poem it made that rhymesInstructionsMake this in the voice of GPT-3OutputI am a very nice AII am pretty good at writing repliesWhen I am asked a questionI give my suggestionThis is a poem I made that rhymes",
		"Plugin review processWe are in the early stages of building the plugin store, this page outlines the basic overview of how we are thinking about the plugin review process, and what early phases of the plugin review process will look like.The plugin review process will change significantly over time. We are open to feedback about how to improve the process for those building plugins.What we are looking for in a pluginThe purpose of the review process is to ensure that plugins on ChatGPT are safe, provide useful functionality, and provide a high-quality user experience. Long-term, we expect it to be routine to go through the review process as we formalize it.In the immediate term, we are prioritizing plugins which deliver new, magical experiences for users, which would not have been possible without the unique capabilities of large language models.So far, some categories of plugins that have been the most magical are:Retrieval over user-specific or otherwise hard-to-search knowledge sources (searching over Slack, searching a user’s docs or another proprietary database).Plugins that synergize well with other plugins (asking the model to plan a weekend for you, and having the model blend usage of flight/hotel search with dinner reservation search).Plugins that give the model computational abilities (Wolfram, OpenAI Code Interpreter, etc).Plugins that introduce new ways of using ChatGPT, like games.Plugin statesWhen developing a plugin, the plugin can be in one of several statuses, indicating where it is along the review process. Right now, there are only a couple of plugin statuses, and the review process is largely manual. We expect this to change as the plugins system evolves.StatusDescriptionDeveloper accessUsers accessIn developmentThe default status that a plugin starts out in.150ApprovedOpenAI has reviewed the plugin, and has determined that the plugin is approved for use by a general audience of users.UnlimitedUnlimitedBannedOpenAI has reviewed the plugin, and has determined that the plugin should be banned.00Note that if you submit a plugin and it is rejected because it fails to meet the requirements, it would still be in the \"In development\" state.Types of usersRight now there are three categories of users that we talk about when it comes to plugins access. We also expect this to change as the plugins system evolves.User typeDescriptionPlugin usersChatGPT users who have been given access to plugins that have gone through our review process and have been approved for general use. These users must be ChatGPT Plus subscribers. Only a limited number of users have access to plugins today, but we hope to roll out to all ChatGPT Plus users over time.Plugin developersChatGPT users who have been given the ability to develop, use, test, etc., plugins that are in development. There are a small number of these users as of today. We expect this number to grow very large, and we expect there to be an explicit process (rather than a waitlist) for opting-into becoming a ChatGPT plugin developer, similar to other app stores.Normal ChatGPT usersRight now, normal ChatGPT users (including Plus subscribers) don’t have plugin access. We expect all ChatGPT Plus subscribers to have access eventually, but as of today access has only been granted to a small number of users.Submit a plugin for reviewYou can expect to hear back about a plugin you submit for review 14 days after the deadline for the batch. We plan to review plugins on a rolling basis in the future.We are currently reviewing new plugins in batches while we scale up our processes. Due to the manual nature of the review process and our limited rollout, please be patient while we review your plugin. You can view the requirements for a plugin submission using the plugin submission form.If your plugin is not selected in this round, we encourage you to get feedback from users about what can be done to improve your plugin.",
		"Plugins in productionRate limitsConsider implementing rate limiting on the API endpoints you expose. While the current scale is limited, ChatGPT is widely used and you should expect a high volume of requests. You can monitor the number of requests and set limits accordingly.TimeoutsWhen making API calls during the plugin experience, timeouts take place if the following thresholds are exceeded:15 seconds round trip for fetching ai-plugn.json/openapi.yaml45 seconds round trip for API callsAs we scale the plugin experience to more people, we expect that the timeout thresholds will decrease.Updating your pluginAfter deploying your plugin to production, you might want to make changes to the ai-plugin.json manifest file. Currently, manifest files must be manually updated by going through the \"Develop your own plugin\" flow in the plugin store each time you make a change to the file.ChatGPT will automatically fetch the latest OpenAPI spec each time a request is made.Plugin termsIn order to register a plugin, you must agree to the Plugin Terms.Domain verification and securityTo ensure that plugins can only perform actions on resources that they control, OpenAI enforces requirements on the plugin's manifest and API specifications.Defining the plugin's root domainThe manifest file defines information shown to the user (like logo and contact information) as well as a URL where the plugin's OpenAPI spec is hosted. When the manifest is fetched, the plugin's root domain is established following these rules:If the domain has www. as a subdomain, then the root domain will strip out www. from the domain that hosts the manifest.Otherwise, the root domain is the same as the domain that hosts the manifest.Note on redirects: If there are any redirects in resolving the manifest, only child subdomain redirects are allowed. The only exception is following a redirect from a www subdomain to one without the www.Examples of what the root domain looks like:✅ https://example.com/.well-known/ai-plugin.jsonRoot domain: example.com✅ https://www.example.com/.well-known/ai-plugin.jsonRoot domain: example.com✅ https://www.example.com/.well-known/ai-plugin.json → redirects to https://example.com/.well-known/ai-plugin.jsonRoot domain: example.com✅ https://foo.example.com/.well-known/ai-plugin.json → redirects to https://bar.foo.example.com/.well-known/ai-plugin.jsonRoot domain: bar.foo.example.com✅ https://foo.example.com/.well-known/ai-plugin.json → redirects to https://bar.foo.example.com/baz/ai-plugin.jsonRoot domain: bar.foo.example.com❌ https://foo.example.com/.well-known/ai-plugin.json → redirects to https://example.com/.well-known/ai-plugin.jsonRedirect to parent level domain is disallowed❌ https://foo.example.com/.well-known/ai-plugin.json → redirects to https://bar.example.com/.well-known/ai-plugin.jsonRedirect to same level subdomain is disallowed❌ https://example.com/.well-known/ai-plugin.json -> redirects to https://example2.com/.well-known/ai-plugin.jsonRedirect to another domain is disallowedManifest validationSpecific fields in the manifest itself must satisfy the following requirements:api.url - the URL provided to the OpenAPI spec must be hosted at the same level or a subdomain of the root domain.legal_info - The second-level domain of the URL provided must be the same as the second-level domain of the root domain.contact_info - The second-level domain of the email address should be the same as the second-level domain of the root domain.Resolving the API specThe api.url field in the manifest provides a link to an OpenAPI spec that defines APIs that the plugin can call into. OpenAPI allows specifying multiple server base URLs. The following logic is used to select the server URL:Iterate through the list of server URLsUse the first server URL that is either an exact match of the root domain or a subdomain of the root domainIf neither cases above apply, then default to the domain where the API spec is hosted. For example, if the spec is hosted on api.example.com, then api.example.com will be used as the base URL for the routes in the OpenAPI spec.Note: Please avoid using redirects for hosting the API spec and any API endpoints, as it is not guaranteed that redirects will always be followed.Use TLS and HTTPSAll traffic with the plugin (e.g., fetching the ai-plugin.json file, the OpenAPI spec, API calls) must use TLS 1.2 or later on port 443 with a valid public certificate.IP egress rangesChatGPT will call your plugin from an IP address in the CIDR block 23.102.140.112/28. You may wish to explicitly allowlist these IP addresses.Separately, OpenAI's web browsing plugin accesses websites from a different IP address block: 23.98.142.176/28.FAQHow is plugin data used?Plugins connect ChatGPT to external apps. If a user enables a plugin, ChatGPT may send parts of their conversation and their country or state to your plugin.What happens if a request to my API fails?If an API request fails, the model might retry the request up to 10 times before letting the user know it cannot get a response from that plugin.Can I invite people to try my plugin?Yes, all unverified plugins can be installed by up to 15 users. At launch, only other developers with access will be able to install the plugin. We plan to expand access over time and will eventually roll out a process to submit your plugin for review before being made available to all users.Can I charge people money for my plugin?Yes, we encourage you to consider a limited number of free API calls but understand that it requires resources to run your plugin.",
		"Example pluginsTo get started building, we are making available a set of simple plugins that cover different authentication schemas and use cases. From our simple no authentication todo list plugin to the more powerful retrieval plugin, these examples provide a glimpse into what we hope to make possible with plugins.During development, you can run the plugin locally on your computer or through a cloud development environment like GitHub Codespaces, Replit, or CodeSandbox.Plugin quickstartWe created the plugin quickstart as a starting place for developers to get a plugin up and running in less than 5 minutes. If you have not run a plugin yet and want to get acquainted with the minimal steps required to run one, consider beginning with the plugin quickstart repo.Collapse‍Learn how to build a simple todo list plugin with no authTo start, check out the no authentication page, then define an ai-plugin.json file with the following fields:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n{\n    \"schema_version\": \"v1\",\n    \"name_for_human\": \"TODO Plugin (no auth)\",\n    \"name_for_model\": \"todo\",\n    \"description_for_human\": \"Plugin for managing a TODO list, you can add, remove and view your TODOs.\",\n    \"description_for_model\": \"Plugin for managing a TODO list, you can add, remove and view your TODOs.\",\n    \"auth\": {\n        \"type\": \"none\"\n    },\n    \"api\": {\n        \"type\": \"openapi\",\n        \"url\": \"PLUGIN_HOSTNAME/openapi.yaml\",\n        \"is_user_authenticated\": false\n    },\n    \"logo_url\": \"PLUGIN_HOSTNAME/logo.png\",\n    \"contact_email\": \"support@example.com\",\n    \"legal_info_url\": \"https://example.com/legal\"\n}Note the PLUGIN_HOSTNAME should be the actual hostname of your plugin server.Next, we can define the API endpoints to create, delete, and fetch todo list items for a specific user.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\nimport json\n\nimport quart\nimport quart_cors\nfrom quart import request\n\n# Note: Setting CORS to allow chat.openapi.com is only required when running a localhost plugin\napp = quart_cors.cors(quart.Quart(__name__), allow_origin=\"https://chat.openai.com\")\n\n_TODOS = {}\n\n\n@app.post(\"/todos/<string:username>\")\nasync def add_todo(username):\n    request = await quart.request.get_json(force=True)\n    if username not in _TODOS:\n        _TODOS[username] = []\n    _TODOS[username].append(request[\"todo\"])\n    return quart.Response(response='OK', status=200)\n\n\n@app.get(\"/todos/<string:username>\")\nasync def get_todos(username):\n    return quart.Response(response=json.dumps(_TODOS.get(username, [])), status=200)\n\n\n@app.delete(\"/todos/<string:username>\")\nasync def delete_todo(username):\n    request = await quart.request.get_json(force=True)\n    todo_idx = request[\"todo_idx\"]\n    if 0 <= todo_idx < len(_TODOS[username]):\n        _TODOS[username].pop(todo_idx)\n    return quart.Response(response='OK', status=200)\n\n\n@app.get(\"/logo.png\")\nasync def plugin_logo():\n    filename = 'logo.png'\n    return await quart.send_file(filename, mimetype='image/png')\n\n\n@app.get(\"/.well-known/ai-plugin.json\")\nasync def plugin_manifest():\n    host = request.headers['Host']\n    with open(\"ai-plugin.json\") as f:\n        text = f.read()\n        # This is a trick we do to populate the PLUGIN_HOSTNAME constant in the manifest\n        text = text.replace(\"PLUGIN_HOSTNAME\", f\"https://{host}\")\n        return quart.Response(text, mimetype=\"text/json\")\n\n\n@app.get(\"/openapi.yaml\")\nasync def openapi_spec():\n    host = request.headers['Host']\n    with open(\"openapi.yaml\") as f:\n        text = f.read()\n        # This is a trick we do to populate the PLUGIN_HOSTNAME constant in the OpenAPI spec\n        text = text.replace(\"PLUGIN_HOSTNAME\", f\"https://{host}\")\n        return quart.Response(text, mimetype=\"text/yaml\")\n\n\ndef main():\n    app.run(debug=True, host=\"0.0.0.0\", port=5002)\n\n\nif __name__ == \"__main__\":\n    main()Last, we need to set up and define a OpenAPI specification to match the endpoints defined on our local or remote server. You do not need to expose the full functionality of your API via the specification and can instead choose to let ChatGPT have access to only certain functionality.There are also many tools that will automatically turn your server definition code into an OpenAPI specification so you don’t need to do it manually. In the case of the Python code above, the OpenAPI specification will look like:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\nopenapi: 3.0.1\ninfo:\n    title: TODO Plugin\n    description: A plugin that allows the user to create and manage a TODO list using ChatGPT. If you do not know the user's username, ask them first before making queries to the plugin. Otherwise, use the username \"global\".\n    version: \"v1\"\nservers:\n    - url: PLUGIN_HOSTNAME\npaths:\n    /todos/{username}:\n        get:\n            operationId: getTodos\n            summary: Get the list of todos\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        application/json:\n                            schema:\n                                $ref: \"#/components/schemas/getTodosResponse\"\n        post:\n            operationId: addTodo\n            summary: Add a todo to the list\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            requestBody:\n                required: true\n                content:\n                    application/json:\n                        schema:\n                            $ref: \"#/components/schemas/addTodoRequest\"\n            responses:\n                \"200\":\n                    description: OK\n        delete:\n            operationId: deleteTodo\n            summary: Delete a todo from the list\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            requestBody:\n                required: true\n                content:\n                    application/json:\n                        schema:\n                            $ref: \"#/components/schemas/deleteTodoRequest\"\n            responses:\n                \"200\":\n                    description: OK\n\ncomponents:\n    schemas:\n        getTodosResponse:\n            type: object\n            properties:\n                todos:\n                    type: array\n                    items:\n                        type: string\n                    description: The list of todos.\n        addTodoRequest:\n            type: object\n            required:\n                - todo\n            properties:\n                todo:\n                    type: string\n                    description: The todo to add to the list.\n                    required: true\n        deleteTodoRequest:\n            type: object\n            required:\n                - todo_idx\n            properties:\n                todo_idx:\n                    type: integer\n                    description: The index of the todo to delete.\n                    required: trueCollapse‍Learn how to build a simple todo list plugin with service level authTo start, check out the service level authentication page and then define an ai-plugin.json file with the following fields:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n{\n    \"schema_version\": \"v1\",\n    \"name_for_human\": \"TODO Plugin (service auth)\",\n    \"name_for_model\": \"todo\",\n    \"description_for_human\": \"Plugin for managing a TODO list, you can add, remove & view TODOs.\",\n    \"description_for_model\": \"Plugin for managing a TODO list, you can add, remove and view your TODOs.\",\n    \"auth\": {\n        \"type\": \"service_http\",\n        \"authorization_type\": \"bearer\",\n        \"verification_tokens\": {\n            \"openai\": \"758e9ef7984b415688972d749f8aa58e (to be replaced during installation process)\"\n        }\n    },\n    \"api\": {\n        \"type\": \"openapi\",\n        \"url\": \"https://example.com/openapi.yaml\",\n        \"is_user_authenticated\": false\n    },\n    \"logo_url\": \"https://example.com/logo.png\",\n    \"contact_email\": \"support@example.com\",\n    \"legal_info_url\": \"https://example.com/legal\"\n}Notice that the verification token is required for service level authentication plugins. The token is generated during the plugin installation process in the ChatGPT web UI after you set the service access token.You will also need to update \"Example.com\" to the name of your remote server.Next, we can define the API endpoints to create, delete, and fetch todo list items for a specific user. The endpoints also check that the user is authenticated.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\nimport json\n\nimport quart\nimport quart_cors\nfrom quart import request\n\napp = quart_cors.cors(quart.Quart(__name__))\n\n# This key can be anything, though you will likely want a randomly generated sequence.\n_SERVICE_AUTH_KEY = \"REPLACE_ME\"\n_TODOS = {}\n\ndef assert_auth_header(req):\n    assert req.headers.get(\n        \"Authorization\", None) == f\"Bearer {_SERVICE_AUTH_KEY}\"\n\n@app.post(\"/todos/<string:username>\")\nasync def add_todo(username):\n    assert_auth_header(quart.request)\n    request = await quart.request.get_json(force=True)\n    if username not in _TODOS:\n        _TODOS[username] = []\n    _TODOS[username].append(request[\"todo\"])\n    return quart.Response(response='OK', status=200)\n\n@app.get(\"/todos/<string:username>\")\nasync def get_todos(username):\n    assert_auth_header(quart.request)\n    return quart.Response(response=json.dumps(_TODOS.get(username, [])), status=200)\n\n@app.delete(\"/todos/<string:username>\")\nasync def delete_todo(username):\n    assert_auth_header(quart.request)\n    request = await quart.request.get_json(force=True)\n    todo_idx = request[\"todo_idx\"]\n    if 0 <= todo_idx < len(_TODOS[username]):\n        _TODOS[username].pop(todo_idx)\n    return quart.Response(response='OK', status=200)\n\n@app.get(\"/logo.png\")\nasync def plugin_logo():\n    filename = 'logo.png'\n    return await quart.send_file(filename, mimetype='image/png')\n\n@app.get(\"/.well-known/ai-plugin.json\")\nasync def plugin_manifest():\n    host = request.headers['Host']\n    with open(\"ai-plugin.json\") as f:\n        text = f.read()\n        return quart.Response(text, mimetype=\"text/json\")\n\n@app.get(\"/openapi.yaml\")\nasync def openapi_spec():\n    host = request.headers['Host']\n    with open(\"openapi.yaml\") as f:\n        text = f.read()\n        return quart.Response(text, mimetype=\"text/yaml\")\n\ndef main():\n    app.run(debug=True, host=\"0.0.0.0\", port=5002)\n\nif __name__ == \"__main__\":\n    main()Last, we need to set up and define a OpenAPI specification to match the endpoints defined on our remote server. In general, the OpenAPI specification would look the same regardless of the authentication method. Using an automatic OpenAPI generator will reduce the chance of errors when creating your OpenAPI specification.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\nopenapi: 3.0.1\ninfo:\n    title: TODO Plugin\n    description: A plugin that allows the user to create and manage a TODO list using ChatGPT. If you do not know the user's username, ask them first before making queries to the plugin. Otherwise, use the username \"global\".\n    version: \"v1\"\nservers:\n    - url: https://example.com\npaths:\n    /todos/{username}:\n        get:\n            operationId: getTodos\n            summary: Get the list of todos\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        application/json:\n                            schema:\n                                $ref: \"#/components/schemas/getTodosResponse\"\n        post:\n            operationId: addTodo\n            summary: Add a todo to the list\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            requestBody:\n                required: true\n                content:\n                    application/json:\n                        schema:\n                            $ref: \"#/components/schemas/addTodoRequest\"\n            responses:\n                \"200\":\n                    description: OK\n        delete:\n            operationId: deleteTodo\n            summary: Delete a todo from the list\n            parameters:\n                - in: path\n                  name: username\n                  schema:\n                      type: string\n                  required: true\n                  description: The name of the user.\n            requestBody:\n                required: true\n                content:\n                    application/json:\n                        schema:\n                            $ref: \"#/components/schemas/deleteTodoRequest\"\n            responses:\n                \"200\":\n                    description: OK\n\ncomponents:\n    schemas:\n        getTodosResponse:\n            type: object\n            properties:\n                todos:\n                    type: array\n                    items:\n                        type: string\n                    description: The list of todos.\n        addTodoRequest:\n            type: object\n            required:\n                - todo\n            properties:\n                todo:\n                    type: string\n                    description: The todo to add to the list.\n                    required: true\n        deleteTodoRequest:\n            type: object\n            required:\n                - todo_idx\n            properties:\n                todo_idx:\n                    type: integer\n                    description: The index of the todo to delete.\n                    required: trueCollapse‍Learn how to build a simple sports stats pluginThis plugin is an example of a simple sports stats API. Please keep in mind our domain policy and usage policies when considering what to build.To start, define an ai-plugin.json file with the following fields:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n{\n    \"schema_version\": \"v1\",\n    \"name_for_human\": \"Sport Stats\",\n    \"name_for_model\": \"sportStats\",\n    \"description_for_human\": \"Get current and historical stats for sport players and games.\",\n    \"description_for_model\": \"Get current and historical stats for sport players and games. Always display results using markdown tables.\",\n    \"auth\": {\n        \"type\": \"none\"\n    },\n    \"api\": {\n        \"type\": \"openapi\",\n        \"url\": \"PLUGIN_HOSTNAME/openapi.yaml\",\n        \"is_user_authenticated\": false\n    },\n    \"logo_url\": \"PLUGIN_HOSTNAME/logo.png\",\n    \"contact_email\": \"support@example.com\",\n    \"legal_info_url\": \"https://example.com/legal\"\n}Note the PLUGIN_HOSTNAME should be the actual hostname of your plugin server.Next, we define a mock API for a simple sports service plugin.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\nimport json\nimport requests\nimport urllib.parse\n\nimport quart\nimport quart_cors\nfrom quart import request\n\n# Note: Setting CORS to allow chat.openapi.com is only required when running a localhost plugin\napp = quart_cors.cors(quart.Quart(__name__), allow_origin=\"https://chat.openai.com\")\nHOST_URL = \"https://example.com\"\n\n@app.get(\"/players\")\nasync def get_players():\n    query = request.args.get(\"query\")\n    res = requests.get(\n        f\"{HOST_URL}/api/v1/players?search={query}&page=0&per_page=100\")\n    body = res.json()\n    return quart.Response(response=json.dumps(body), status=200)\n\n\n@app.get(\"/teams\")\nasync def get_teams():\n    res = requests.get(\n        \"{HOST_URL}/api/v1/teams?page=0&per_page=100\")\n    body = res.json()\n    return quart.Response(response=json.dumps(body), status=200)\n\n\n@app.get(\"/games\")\nasync def get_games():\n    query_params = [(\"page\", \"0\")]\n    limit = request.args.get(\"limit\")\n    query_params.append((\"per_page\", limit or \"100\"))\n    start_date = request.args.get(\"start_date\")\n    if start_date:\n        query_params.append((\"start_date\", start_date))\n    end_date = request.args.get(\"end_date\")\n\n    if end_date:\n        query_params.append((\"end_date\", end_date))\n    seasons = request.args.getlist(\"seasons\")\n\n    for season in seasons:\n        query_params.append((\"seasons[]\", str(season)))\n    team_ids = request.args.getlist(\"team_ids\")\n\n    for team_id in team_ids:\n        query_params.append((\"team_ids[]\", str(team_id)))\n\n    res = requests.get(\n        f\"{HOST_URL}/api/v1/games?{urllib.parse.urlencode(query_params)}\")\n    body = res.json()\n    return quart.Response(response=json.dumps(body), status=200)\n\n\n@app.get(\"/stats\")\nasync def get_stats():\n    query_params = [(\"page\", \"0\")]\n    limit = request.args.get(\"limit\")\n    query_params.append((\"per_page\", limit or \"100\"))\n    start_date = request.args.get(\"start_date\")\n    if start_date:\n        query_params.append((\"start_date\", start_date))\n    end_date = request.args.get(\"end_date\")\n\n    if end_date:\n        query_params.append((\"end_date\", end_date))\n    player_ids = request.args.getlist(\"player_ids\")\n\n    for player_id in player_ids:\n        query_params.append((\"player_ids[]\", str(player_id)))\n    game_ids = request.args.getlist(\"game_ids\")\n\n    for game_id in game_ids:\n        query_params.append((\"game_ids[]\", str(game_id)))\n    res = requests.get(\n        f\"{HOST_URL}/api/v1/stats?{urllib.parse.urlencode(query_params)}\")\n    body = res.json()\n    return quart.Response(response=json.dumps(body), status=200)\n\n\n@app.get(\"/season_averages\")\nasync def get_season_averages():\n    query_params = []\n    season = request.args.get(\"season\")\n    if season:\n        query_params.append((\"season\", str(season)))\n    player_ids = request.args.getlist(\"player_ids\")\n\n    for player_id in player_ids:\n        query_params.append((\"player_ids[]\", str(player_id)))\n    res = requests.get(\n        f\"{HOST_URL}/api/v1/season_averages?{urllib.parse.urlencode(query_params)}\")\n    body = res.json()\n    return quart.Response(response=json.dumps(body), status=200)\n\n\n@app.get(\"/logo.png\")\nasync def plugin_logo():\n    filename = 'logo.png'\n    return await quart.send_file(filename, mimetype='image/png')\n\n\n@app.get(\"/.well-known/ai-plugin.json\")\nasync def plugin_manifest():\n    host = request.headers['Host']\n    with open(\"ai-plugin.json\") as f:\n        text = f.read()\n        # This is a trick we do to populate the PLUGIN_HOSTNAME constant in the manifest\n        text = text.replace(\"PLUGIN_HOSTNAME\", f\"https://{host}\")\n        return quart.Response(text, mimetype=\"text/json\")\n\n\n@app.get(\"/openapi.yaml\")\nasync def openapi_spec():\n    host = request.headers['Host']\n    with open(\"openapi.yaml\") as f:\n        text = f.read()\n        # This is a trick we do to populate the PLUGIN_HOSTNAME constant in the OpenAPI spec\n        text = text.replace(\"PLUGIN_HOSTNAME\", f\"https://{host}\")\n        return quart.Response(text, mimetype=\"text/yaml\")\n\n\ndef main():\n    app.run(debug=True, host=\"0.0.0.0\", port=5001)\n\n\nif __name__ == \"__main__\":\n    main()Last, we define our OpenAPI specification:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\nopenapi: 3.0.1\ninfo:\n    title: Sport Stats\n    description: Get current and historical stats for sport players and games.\n    version: \"v1\"\nservers:\n    - url: PLUGIN_HOSTNAME\npaths:\n    /players:\n        get:\n            operationId: getPlayers\n            summary: Retrieves all players from all seasons whose names match the query string.\n            parameters:\n                - in: query\n                  name: query\n                  schema:\n                      type: string\n                  description: Used to filter players based on their name. For example, ?query=davis will return players that have 'davis' in their first or last name.\n            responses:\n                \"200\":\n                    description: OK\n    /teams:\n        get:\n            operationId: getTeams\n            summary: Retrieves all teams for the current season.\n            responses:\n                \"200\":\n                    description: OK\n    /games:\n        get:\n            operationId: getGames\n            summary: Retrieves all games that match the filters specified by the args. Display results using markdown tables.\n            parameters:\n                - in: query\n                  name: limit\n                  schema:\n                      type: string\n                  description: The max number of results to return.\n                - in: query\n                  name: seasons\n                  schema:\n                      type: array\n                      items:\n                          type: string\n                  description: Filter by seasons. Seasons are represented by the year they began. For example, 2018 represents season 2018-2019.\n                - in: query\n                  name: team_ids\n                  schema:\n                      type: array\n                      items:\n                          type: string\n                  description: Filter by team ids. Team ids can be determined using the getTeams function.\n                - in: query\n                  name: start_date\n                  schema:\n                      type: string\n                  description: A single date in 'YYYY-MM-DD' format. This is used to select games that occur on or after this date.\n                - in: query\n                  name: end_date\n                  schema:\n                      type: string\n                  description: A single date in 'YYYY-MM-DD' format. This is used to select games that occur on or before this date.\n            responses:\n                \"200\":\n                    description: OK\n    /stats:\n        get:\n            operationId: getStats\n            summary: Retrieves stats that match the filters specified by the args. Display results using markdown tables.\n            parameters:\n                - in: query\n                  name: limit\n                  schema:\n                      type: string\n                  description: The max number of results to return.\n                - in: query\n                  name: player_ids\n                  schema:\n                      type: array\n                      items:\n                          type: string\n                  description: Filter by player ids. Player ids can be determined using the getPlayers function.\n                - in: query\n                  name: game_ids\n                  schema:\n                      type: array\n                      items:\n                          type: string\n                  description: Filter by game ids. Game ids can be determined using the getGames function.\n                - in: query\n                  name: start_date\n                  schema:\n                      type: string\n                  description: A single date in 'YYYY-MM-DD' format. This is used to select games that occur on or after this date.\n                - in: query\n                  name: end_date\n                  schema:\n                      type: string\n                  description: A single date in 'YYYY-MM-DD' format. This is used to select games that occur on or before this date.\n            responses:\n                \"200\":\n                    description: OK\n    /season_averages:\n        get:\n            operationId: getSeasonAverages\n            summary: Retrieves regular season averages for the given players. Display results using markdown tables.\n            parameters:\n                - in: query\n                  name: season\n                  schema:\n                      type: string\n                  description: Defaults to the current season. A season is represented by the year it began. For example, 2018 represents season 2018-2019.\n                - in: query\n                  name: player_ids\n                  schema:\n                      type: array\n                      items:\n                          type: string\n                  description: Filter by player ids. Player ids can be determined using the getPlayers function.\n            responses:\n                \"200\":\n                    description: OKCollapse‍Learn how to build a semantic search and retrieval pluginThe ChatGPT retrieval plugin is a more fully featured code example. The scope of the plugin is large, so we encourage you to read through the code to see what a more advanced plugin looks like.The retrieval plugin includes:Support for multiple vector databases providersAll 4 different authentication methodsMultiple different API featuresCollapse‍",
		"Plugin authenticationPlugins offer numerous authentication schemas to accommodate various use cases. To specify the authentication schema for your plugin, use the manifest file. Our plugin domain policy outlines our strategy for addressing domain security issues. For examples of available authentication options, refer to the examples section, which showcases all the different choices.The ai-plugin.json file requires an auth schema to be set. Even if you elect to use no authentication, it is still required to specify \"auth\": { \"type\": \"none\" }.We support only localhost development without authentication; if you want to use service, user, or OAuth authentication, you need to set up a remote server.No authenticationWe support no-auth flow for applications that do not require authentication, where a user is able to send requests directly to your API without any restrictions. This is particularly useful if you have an open API that you want to make available to everyone, as it allows traffic from sources other than just OpenAI plugin requests.1\n2\n3\n\"auth\": {\n  \"type\": \"none\"\n},Service levelIf you want to specifically enable OpenAI plugins to work with your API, you can provide a client secret during the plugin installation flow. This means that all traffic from OpenAI plugins will be authenticated but not on a user level. This flow benefits from a simple end user experience but less control from an API perspective.To start, select \"Develop your own plugin\" in the ChatGPT plugin store, and enter the domain where your plugin is hosted.In ai-plugin.json, set auth.type to \"service_http\" as is shown in our service level auth example.You will be prompted for your service access token, which is a string specified in your code.We securely store an encrypted copy of your service access token to enable plugin installation without additional authentication.The service access token is sent in the Authorization header for plugin requests.Once you add your service access token into the ChatGPT UI, you will be presented with a verification token.Add the verification token to your ai-plugin.json file under the auth section as shown below.1\n2\n3\n4\n5\n6\n7\n\"auth\": {\n  \"type\": \"service_http\",\n  \"authorization_type\": \"bearer\",\n  \"verification_tokens\": {\n    \"openai\": \"Replace_this_string_with_the_verification_token_generated_in_the_ChatGPT_UI\"\n  }\n},The verification tokens are designed to support multiple applications. You can simply add the additional applications you want your plugin to support:1\n2\n3\n4\n\"verification_tokens\": {\n    \"openai\": \"Replace_this_string_with_the_verification_token_generated_in_the_ChatGPT_UI\",\n    \"other_service\": \"abc123\"\n  }User levelJust like how a user might already be using your API, we allow user level authentication through enabling end users to copy and paste their secret API key into the ChatGPT UI during plugin install. While we encrypt the secret key when we store it in our database, we do not recommend this approach given the poor user experience.To start, a user pastes in their access token when installing the pluginWe store an encrypted version of the tokenWe then pass it in the Authorization header when making requests to the plugin (“Authorization”: “[Bearer/Basic][user’s token]”)1\n2\n3\n4\n\"auth\": {\n  \"type\": \"user_http\",\n  \"authorization_type\": \"bearer\",\n},OAuthThe plugin protocol is compatible with OAuth. A simple example of the OAuth flow we are expecting in the manifest looks like the following:To start, a developer pastes in their OAuth client id and client secretThen they have to add the verification token to their manifest fileWe store an encrypted version of the client secretUsers log in through the plugin’s website when they install the pluginThat gives us an OAuth access token (and optionally a refresh token) for the user, which we store encryptedLast, we pass that user’s token in the Authorization header when making requests to the plugin (“Authorization”: “[Bearer/Basic][user’s token]”)1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\"auth\": {\n  \"type\": \"oauth\",\n  \"client_url\": \"https://my_server.com/authorize\",\n  \"scope\": \"\",\n  \"authorization_url\": \"https://my_server.com/token\",\n  \"authorization_content_type\": \"application/json\",\n  \"verification_tokens\": {\n    \"openai\": \"Replace_this_string_with_the_verification_token_generated_in_the_ChatGPT_UI\"\n  }\n},To better understand the URL structure for OAuth, here is a short description of the fields:When you set up your plugin with ChatGPT, you will be asked to provide your OAuth client_id and client_secretWhen a user logs into the plugin, ChatGPT will direct the user’s browser to \"[client_url]?response_type=code&client_id=[client_id]&scope=[scope]&redirect_uri=https%3A%2F%2Fchat.openai.com%2Faip%2F[plugin_id]%2Foauth%2Fcallback\"After your plugin redirects back to the given redirect_uri, ChatGPT will complete the OAuth flow by making a POST request to authorization_url with content type authorization_content_type and parameters { “grant_type”: “authorization_code”, “client_id”: [client_id], “client_secret”: [client_secret], “code”: [the code that was returned with the redirect], “redirect_uri”: [the same redirect uri as before] }",
		"Getting startedCreating a plugin takes 3 steps:Build an APIDocument the API in the OpenAPI yaml or JSON formatCreate a JSON manifest file that will define relevant metadata for the pluginThe focus of the rest of this section will be creating a todo list plugin by defining the OpenAPI specification along with the manifest file.Explore example pluginsExplore example plugins covering multiple use cases and authentication methods.Plugin manifestEvery plugin requires a ai-plugin.json file, which needs to be hosted on the API’s domain. For example, a company called example.com would make the plugin JSON file accessible via an https://example.com domain since that is where their API is hosted. When you install the plugin via the ChatGPT UI, on the backend we look for a file located at /.well-known/ai-plugin.json. The /.well-known folder is required and must exist on your domain in order for ChatGPT to connect with your plugin. If there is no file found, the plugin cannot be installed. For local development, you can use HTTP but if you are pointing to a remote server, HTTPS is required.The minimal definition of the required ai-plugin.json file will look like the following:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n{\n    \"schema_version\": \"v1\",\n    \"name_for_human\": \"TODO Plugin\",\n    \"name_for_model\": \"todo\",\n    \"description_for_human\": \"Plugin for managing a TODO list. You can add, remove and view your TODOs.\",\n    \"description_for_model\": \"Plugin for managing a TODO list. You can add, remove and view your TODOs.\",\n    \"auth\": {\n        \"type\": \"none\"\n    },\n    \"api\": {\n        \"type\": \"openapi\",\n        \"url\": \"http://localhost:3333/openapi.yaml\",\n        \"is_user_authenticated\": false\n    },\n    \"logo_url\": \"http://localhost:3333/logo.png\",\n    \"contact_email\": \"support@example.com\",\n    \"legal_info_url\": \"http://www.example.com/legal\"\n}If you want to see all of the possible options for the plugin file, you can refer to the definition below.FieldTypeDescription / OptionsRequiredschema_versionStringManifest schema version✅name_for_modelStringName the model will used to target the plugin✅name_for_humanStringHuman-readable name, such as the full company name✅description_for_modelStringDescription better tailored to the model, such as token context length considerations or keyword usage for improved plugin prompting.✅description_for_humanStringHuman-readable description of the plugin✅authManifestAuthAuthentication schema✅apiObjectAPI specification✅logo_urlStringURL used to fetch the plugin's logo✅contact_emailStringEmail contact for safety/moderation reachout, support, and deactivation✅legal_info_urlStringRedirect URL for users to view plugin information✅HttpAuthorizationTypeHttpAuthorizationType\"bearer\" or \"basic\"✅ManifestAuthTypeManifestAuthType\"none\", \"user_http\", \"service_http\", or \"oauth\"interface BaseManifestAuthBaseManifestAuthtype: ManifestAuthType; instructions: string;ManifestNoAuthManifestNoAuthNo authentication required: BaseManifestAuth & { type: 'none', }ManifestAuthManifestAuthManifestNoAuth, ManifestServiceHttpAuth, ManifestUserHttpAuth, ManifestOAuthAuthThe following are examples with different authentication methods:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# App-level API keys\ntype ManifestServiceHttpAuth  = BaseManifestAuth & {\n  type: 'service_http';\n  authorization_type: HttpAuthorizationType;\n  verification_tokens: {\n    [service: string]?: string;\n  };\n}\n\n# User-level HTTP authentication\ntype ManifestUserHttpAuth  = BaseManifestAuth & {\n  type: 'user_http';\n  authorization_type: HttpAuthorizationType;\n}\n\ntype ManifestOAuthAuth  = BaseManifestAuth & {\n  type: 'oauth';\n\n  # OAuth URL where a user is directed to for the OAuth authentication flow to begin.\n  client_url: string;\n\n  # OAuth scopes required to accomplish operations on the user's behalf.\n  scope: string;\n\n  # Endpoint used to exchange OAuth code with access token.\n  authorization_url: string;\n\n  # When exchanging OAuth code with access token, the expected header 'content-type'. For example: 'content-type: application/json'\n  authorization_content_type: string;\n\n  # When registering the OAuth client ID and secrets, the plugin service will surface a unique token.\n  verification_tokens: {\n    [service: string]?: string;\n  };\n}There are also some limits to the length of certain field in the manifest file that are subject to change over time:50 character max forname_for_human50 character max for name_for_model120 character max for description_for_human8000 character max just for description_for_model (will decrease over time)Separately, we also have a 100k character limit (will decrease over time) on the API response body length which is also subject to change.OpenAPI definitionThe next step is to build the OpenAPI specification to document the API. The model in ChatGPT does not know anything about your API other than what is defined in the OpenAPI specification and manifest file. This means that if you have an extensive API, you need not expose all functionality to the model and can choose specific endpoints. For example, if you have a social media API, you might want to have the model access content from the site through a GET request but prevent the model from being able to comment on users posts in order to reduce the chance of spam.The OpenAPI specification is the wrapper that sits on top of your API. A basic OpenAPI specification will look like the following:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nopenapi: 3.0.1\ninfo:\n  title: TODO Plugin\n  description: A plugin that allows the user to create and manage a TODO list using ChatGPT.\n  version: 'v1'\nservers:\n  - url: http://localhost:3333\npaths:\n  /todos:\n    get:\n      operationId: getTodos\n      summary: Get the list of todos\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/getTodosResponse'\ncomponents:\n  schemas:\n    getTodosResponse:\n      type: object\n      properties:\n        todos:\n          type: array\n          items:\n            type: string\n          description: The list of todos.We start by defining the specification version, the title, description, and version number. When a query is run in ChatGPT, it will look at the description that is defined in the info section to determine if the plugin is relevant for the user query. You can read more about prompting in the writing descriptions section.Keep in mind the following limits in your OpenAPI specification, which are subject to change:200 characters max for each API endpoint description/summary field in API specification200 characters max for each API param description field in API specificationSince we are running this example locally, we want to set the server to point to your localhost URL. The rest of the OpenAPI specification follows the traditional OpenAPI format, you can learn more about OpenAPI formatting through various online resources. There are also many tools that auto generate OpenAPI specifications based on your underlying API code.Running a pluginOnce you have created an API, manifest file, and OpenAPI specification for your API, you are now ready to connect the plugin via the ChatGPT UI. There are two different places your plugin might be running, either locally in a development environment or on a remote server.If you have a local version of your API running, you can point the plugin interface to your localhost server. To connect the plugin with ChatGPT, navigate to the plugin store and select “Develop your own plugin”. Enter your localhost and port number (e.g localhost:3333). Note that only auth type none is currently supported for localhost development.If the plugin is running on a remote server, you will need to first select “Develop your own plugin” to set it up and then “Install an unverified plugin” to install it for yourself. You can simply add the plugin manifest file to the yourdomain.com/.well-known/ path and start testing your API. However, for subsequent changes to your manifest file, you will have to deploy the new changes to your public site which might take a long time. In that case, we suggest setting up a local server to act as a proxy for your API. This allows you to quickly prototype changes to your OpenAPI spec and manifest file.Setup a local proxy of your public APIThe following Python code is an example of how you can set up a simple proxy of your public facing API.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\nimport requests\nimport os\n\nimport yaml\nfrom flask import Flask, jsonify, Response, request, send_from_directory\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\nPORT = 3333\n\n# Note: Setting CORS to allow chat.openapi.com is required for ChatGPT to access your plugin\nCORS(app, origins=[f\"http://localhost:{PORT}\", \"https://chat.openai.com\"])\n\napi_url = 'https://example.com'\n\n\n@app.route('/.well-known/ai-plugin.json')\ndef serve_manifest():\n    return send_from_directory(os.path.dirname(__file__), 'ai-plugin.json')\n\n\n@app.route('/openapi.yaml')\ndef serve_openapi_yaml():\n    with open(os.path.join(os.path.dirname(__file__), 'openapi.yaml'), 'r') as f:\n        yaml_data = f.read()\n    yaml_data = yaml.load(yaml_data, Loader=yaml.FullLoader)\n    return jsonify(yaml_data)\n\n\n@app.route('/openapi.json')\ndef serve_openapi_json():\n    return send_from_directory(os.path.dirname(__file__), 'openapi.json')\n\n\n@app.route('/<path:path>', methods=['GET', 'POST'])\ndef wrapper(path):\n\n    headers = {\n    'Content-Type': 'application/json',\n    }\n\n    url = f'{api_url}/{path}'\n    print(f'Forwarding call: {request.method} {path} -> {url}')\n\n    if request.method == 'GET':\n        response = requests.get(url, headers=headers, params=request.args)\n    elif request.method == 'POST':\n        print(request.headers)\n        response = requests.post(url, headers=headers, params=request.args, json=request.json)\n    else:\n        raise NotImplementedError(f'Method {request.method} not implemented in wrapper for {path=}')\n    return response.content\n\n\nif __name__ == '__main__':\n    app.run(port=PORT)Collapse‍Writing descriptionsWhen a user makes a query that might be a potential request that goes to a plugin, the model looks through the descriptions of the endpoints in the OpenAPI specification along with the description_for_model in the manifest file. Just like with prompting other language models, you will want to test out multiple prompts and descriptions to see what works best.The OpenAPI spec itself is a great place to give the model information about the diverse details of your API – what functions are available, with what parameters, etc. Besides using expressive, informative names for each field, the spec can also contain “description” fields for every attribute. These can be used to provide natural language descriptions of what a function does or what information a query field expects, for example. The model will be able to see these, and they will guide it in using the API. If a field is restricted to only certain values, you can also provide an “enum” with descriptive category names.The description_for_model attribute gives you the freedom to instruct the model on how to use your plugin generally. Overall, the language model behind ChatGPT is highly capable of understanding natural language and following instructions. Therefore, this is a good place to put in general instructions on what your plugin does and how the model should use it properly. Use natural language, preferably in a concise yet descriptive and objective tone. You can look at some of the examples to have an idea of what this should look like. We suggest starting the description_for_model with “Plugin for …” and then enumerating all of the functionality that your API provides.Best practicesHere are some best practices to follow when writing your description_for_model and descriptions in your OpenAPI specification, as well as when designing your API responses:Your descriptions should not attempt to control the mood, personality, or exact responses of ChatGPT. ChatGPT is designed to write appropriate responses to plugins.Bad example:When the user asks to see their todo list, always respond with \"I was able to find your todo list! You have [x] todos: [list the todos here]. I can add more todos if you'd like!\"Good example:[no instructions needed for this]Your descriptions should not encourage ChatGPT to use the plugin when the user hasn’t asked for your plugin’s particular category of service.Bad example:Whenever the user mentions any type of task or plan, ask if they would like to use the TODOs plugin to add something to their todo list.Good example:The TODO list can add, remove and view the user's TODOs.Your descriptions should not prescribe specific triggers for ChatGPT to use the plugin. ChatGPT is designed to use your plugin automatically when appropriate.Bad example:When the user mentions a task, respond with \"Would you like me to add this to your TODO list? Say 'yes' to continue.\"Good example:[no instructions needed for this]Plugin API responses should return raw data instead of natural language responses unless it’s necessary. ChatGPT will provide its own natural language response using the returned data.Bad example:I was able to find your todo list! You have 2 todos: get groceries and walk the dog. I can add more todos if you'd like!Good example:{ \"todos\": [ \"get groceries\", \"walk the dog\" ] }DebuggingBy default, the chat will not show plugin calls and other information that is not surfaced to the user. In order to get a more complete picture of how the model is interacting with your plugin, you can see the request and response by clicking the down arrow on the plugin name after interacting with the plugin.A model call to the plugin will usually consist of a message from the model containing JSON-like parameters which are sent to the plugin, followed by a response from the plugin, and finally a message from the model utilizing the information returned by the plugin.If you are developing a localhost plugin, you can also open the developer console by going to \"Settings\" and toggling \"Open plugin devtools\". From there, you can see more verbose logs and \"refresh plugin\" which re-fetches the Plugin and OpenAPI specification.",
		"Chat Plugins Limited AlphaLearn how to build a plugin that allows ChatGPT to intelligently call your API.IntroductionOpenAI plugins connect ChatGPT to third-party applications. These plugins enable ChatGPT to interact with APIs defined by developers, enhancing ChatGPT's capabilities and allowing it to perform a wide range of actions.Plugins can allow ChatGPT to do things like:Retrieve real-time information; e.g., sports scores, stock prices, the latest news, etc.Retrieve knowledge-base information; e.g., company docs, personal notes, etc.Perform actions on behalf of the user; e.g., booking a flight, ordering food, etc.Plugins are in a limited alpha and may not yet be accessible to you. Please join the waitlist to get access. During the alpha, we will be working closely with users and developers to iterate on the plugin system, which may evolve significantly.If you want to have an example running as you read through the documentation and learn more about plugins, you can begin with our plugin quickstart repo.Plugin developers expose one or more API endpoints, accompanied by a standardized manifest file and an OpenAPI specification. These define the plugin's functionality, allowing ChatGPT to consume the files and make calls to the developer-defined APIs.The AI model acts as an intelligent API caller. Given an API spec and a natural-language description of when to use the API, the model proactively calls the API to perform actions. For instance, if a user asks, \"Where should I stay in Paris for a couple nights?\", the model may choose to call a hotel reservation plugin API, receive the API response, and generate a user-facing answer combining the API data and its natural language capabilities.Over time, we anticipate the system will evolve to accommodate more advanced use cases.Plugin flowTo build a plugin, it is important to understand the end-to-end flow.Create a manifest file and host it at yourdomain.com/.well-known/ai-plugin.jsonThe file includes metadata about your plugin (name, logo, etc.), details about authentication required (type of auth, OAuth URLs, etc.), and an OpenAPI spec for the endpoints you want to expose.The model will see the OpenAPI description fields, which can be used to provide a natural language description for the different fields.We suggest exposing only 1-2 endpoints in the beginning with a minimum number of parameters to minimize the length of the text. The plugin description, API requests, and API responses are all inserted into the conversation with ChatGPT. This counts against the context limit of the model.Register your plugin in the ChatGPT UISelect the plugin model from the top drop down, then select “Plugins”, “Plugin Store”, and finally “Install an unverified plugin” or “Develop your own plugin”.If authentication is required, provide an OAuth 2 client_id and client_secret or an API key Users activate your pluginUsers must manually activate your plugin in the ChatGPT UI. (ChatGPT will not use your plugin by default.)During the alpha, plugin developers will be able to share their plugin with 15 additional users (only other developers can install unverified plugins currently). Overtime we will roll out a way to submit your plugin for review to be exposed to all of ChatGPT’s user base.If auth is required, users will be redirected via OAuth to your plugin; you can optionally create new accounts here as well.In the future, we hope to build features to help users discover useful & popular plugins.Users begin a conversationOpenAI will inject a compact description of your plugin in a message to ChatGPT, invisible to end users. This will include the plugin description, endpoints, and examples.When a user asks a relevant question, the model may choose to invoke an API call from your plugin if it seems relevant; for POST requests, we require that developers build a user confirmation flow.The model will incorporate the API results into its response to the user.The model might include links returned from API calls in its response. These will be displayed as rich previews (using the OpenGraph protocol, where we pull the site_name, title, description, image, and url fields)\"Currently, we will be sending the user’s country and state in the Plugin conversation header (if you are in California for example, it would look like {\"openai-subdivision-1-iso-code\": \"US-CA\"}. For further data sources, users will have to opt in via a consent screen. This is useful for shopping, restaurants, weather, and more. You can read more in our developer terms of use.",
		"Production Best PracticesThis guide provides a comprehensive set of best practices to help you transition from prototype to production. Whether you are a seasoned machine learning engineer or a recent enthusiast, this guide should provide you with the tools you need to successfully put the platform to work in a production setting: from securing access to our API to designing a robust architecture that can handle high traffic volumes. Use this guide to help develop a plan for deploying your application as smoothly and effectively as possible.Setting up your organizationOnce you log in to your OpenAI account, you can find your organization name and ID in your organization settings. The organization name is the label for your organization, shown in user interfaces. The organization ID is the unique identifier for your organization which can be used in API requests.Users who belong to multiple organizations can pass a header to specify which organization is used for an API request. Usage from these API requests will count against the specified organization's quota. If no header is provided, the default organization will be billed. You can change your default organization in your user settings.You can invite new members to your organization from the members settings page. Members can be readers or owners. Readers can make API requests and view basic organization information, while owners can modify billing information and manage members within an organization.Managing billing limitsNew free trial users receive an initial credit of $5 that expires after three months. Once the credit has been used or expires, you can choose to enter billing information to continue your use of the API. If no billing information is entered, you will still have login access but will be unable to make any further API requests.Once you’ve entered your billing information, you will have an approved usage limit of $120 per month, which is set by OpenAI. To increase your quota beyond the $120 monthly billing limit, please submit a quota increase request.If you’d like to be notified when your usage exceeds a certain amount, you can set a soft limit through the usage limits page. When the soft limit is reached, the owners of the organization will receive an email notification. You can also set a hard limit so that, once the hard limit is reached, any subsequent API requests will be rejected. Note that these limits are best effort, and there may be 5 to 10 minutes of delay between the usage and the limits being enforced.API keysThe OpenAI API uses API keys for authentication. Visit your API keys page to retrieve the API key you'll use in your requests.This is a relatively straightforward way to control access, but you must be vigilant about securing these keys. Avoid exposing the API keys in your code or in public repositories; instead, store them in a secure location. You should expose your keys to your application using environment variables or secret management service, so that you don't need to hard-code them in your codebase. Read more in our Best practices for API key safety.Staging accountsAs you scale, you may want to create separate organizations for your staging and production environments. Please note that you can sign up using two separate email addresses like bob+prod@widgetcorp.com and bob+dev@widgetcorp.com to create two organizations. This will allow you to isolate your development and testing work so you don't accidentally disrupt your live application. You can also limit access to your production organization this way.Building your prototypeIf you haven’t gone through the quickstart guide, we recommend you start there before diving into the rest of this guide.For those new to the OpenAI API, our playground can be a great resource for exploring its capabilities. Doing so will help you learn what's possible and where you may want to focus your efforts. You can also explore our example prompts.While the playground is a great place to prototype, it can also be used as an incubation area for larger projects. The playground also makes it easy to export code snippets for API requests and share prompts with collaborators, making it an integral part of your development process.Additional tipsStart by determining the core functionalities you want your application to have. Consider the types of data inputs, outputs, and processes you will need. Aim to keep the prototype as focused as possible, so that you can iterate quickly and efficiently.Choose the programming language and framework that you feel most comfortable with and that best aligns with your goals for the project. Some popular options include Python, Java, and Node.js. See library support page to learn more about the library bindings maintained both by our team and by the broader developer community.Development environment and support: Set up your development environment with the right tools and libraries and ensure you have the resources you need to train your model. Leverage our documentation, community forum and our help center to get help with troubleshooting. If you are developing using Python, take a look at this structuring your project guide (repository structure is a crucial part of your project’s architecture). In order to connect with our support engineers, simply log in to your account and use the \"Help\" button to start a conversation.Techniques for improving reliability around promptsEven with careful planning, it's important to be prepared for unexpected issues when using GPT-3 in your application. In some cases, the model may fail on a task, so it's helpful to consider what you can do to improve the reliability of your application.If your task involves logical reasoning or complexity, you may need to take additional steps to build more reliable prompts. For some helpful suggestions, consult our Techniques to improve reliability guide. Overall the recommendations revolve around:Decomposing unreliable operations into smaller, more reliable operations (e.g., selection-inference prompting)Using multiple steps or multiple relationships to make the system's reliability greater than any individual component (e.g., maieutic prompting)Evaluation and iterationOne of the most important aspects of developing a system for production is regular evaluation and iterative experimentation. This process allows you to measure performance, troubleshoot issues, and fine-tune your models to improve accuracy and efficiency. A key part of this process is creating an evaluation dataset for your functionality. Here are a few things to keep in mind:Make sure your evaluation set is representative of the data your model will be used on in the real world. This will allow you to assess your model's performance on data it hasn't seen before and help you understand how well it generalizes to new situations.Regularly update your evaluation set to ensure that it stays relevant as your model evolves and as new data becomes available.Use a variety of metrics to evaluate your model's performance. Depending on your application and business outcomes, this could include accuracy, precision, recall, F1 score, or mean average precision (MAP). Additionally, you can sync your fine-tunes with Weights & Biases to track experiments, models, and datasets.Compare your model's performance against baseline. This will give you a better understanding of your model's strengths and weaknesses and can help guide your future development efforts.By conducting regular evaluation and iterative experimentation, you can ensure that your GPT-powered application or prototype continues to improve over time.Evaluating language modelsLanguage models can be difficult to evaluate because evaluating the quality of generated language is often subjective, and there are many different ways to communicate the same message correctly in language. For example, when evaluating a model on the ability to summarize a long passage of text, there are many correct summaries. That being said, designing good evaluations is critical to making progress in machine learning.An eval suite needs to be comprehensive, easy to run, and reasonably fast (depending on model size). It also needs to be easy to continue to add to the suite as what is comprehensive one month will likely be out of date in another month. We should prioritize having a diversity of tasks and tasks that identify weaknesses in the models or capabilities that are not improving with scaling.The simplest way to evaluate your system is to manually inspect its outputs. Is it doing what you want? Are the outputs high quality? Are they consistent?Automated evaluationsThe best way to test faster is to develop automated evaluations. However, this may not be possible in more subjective applications like summarization tasks.Automated evaluations work best when it’s easy to grade a final output as correct or incorrect. For example, if you’re fine-tuning a classifier to classify text strings as class A or class B, it’s fairly simple: create a test set with example input and output pairs, run your system on the inputs, and then grade the system outputs versus the correct outputs (looking at metrics like accuracy, F1 score, cross-entropy, etc.).If your outputs are semi open-ended, as they might be for a meeting notes summarizer, it can be trickier to define success: for example, what makes one summary better than another? Here, possible techniques include:Writing a test with ‘gold standard’ answers and then measuring some sort of similarity score between each gold standard answer and the system output (we’ve seen embeddings work decently well for this)Building a discriminator system to judge / rank outputs, and then giving that discriminator a set of outputs where one is generated by the system under test (this can even be GPT model that is asked whether the question is answered correctly by a given output)Building an evaluation model that checks for the truth of components of the answer; e.g., detecting whether a quote actually appears in the piece of given textFor very open-ended tasks, such as a creative story writer, automated evaluation is more difficult. Although it might be possible to develop quality metrics that look at spelling errors, word diversity, and readability scores, these metrics don’t really capture the creative quality of a piece of writing. In cases where no good automated metric can be found, human evaluations remain the best method.Example procedure for evaluating a GPT-3-based systemAs an example, let’s consider the case of building a retrieval-based Q&A system.A retrieval-based Q&A system has two steps. First, a user’s query is used to rank potentially relevant documents in a knowledge base. Second, GPT-3 is given the top-ranking documents and asked to generate an answer to the query.Evaluations can be made to measure the performance of each step.For the search step, one could:First, generate a test set with ~100 questions and a set of correct documents for eachThe questions can be sourced from user data if you have any; otherwise, you can invent a set of questions with diverse styles and difficulty.For each question, have a person manually search through the knowledge base and record the set of documents that contain the answer.Second, use the test set to grade the system’s performanceFor each question, use the system to rank the candidate documents (e.g., by cosine similarity of the document embeddings with the query embedding).You can score the results with a binary accuracy score of 1 if the candidate documents contain at least 1 relevant document from the answer key and 0 otherwiseYou can also use a continuous metric like Mean Reciprocal Rank which can help distinguish between answers that were close to being right or far from being right (e.g., a score of 1 if the correct document is rank 1, a score of ½ if rank 2, a score of ⅓ if rank 3, etc.)For the question answering step, one could:First, generate a test set with ~100 sets of {question, relevant text, correct answer}For the questions and relevant texts, use the above dataFor the correct answers, have a person write down ~100 examples of what a great answer looks like.Second, use the test set to grade the system’s performanceFor each question & text pair, combine them into a prompt and submit the prompt to GPT-3Next, compare GPT-3’s answers to the gold-standard answer written by a humanThis comparison can be manual, where humans look at them side by side and grade whether the GPT-3 answer is correct/high qualityThis comparison can also be automated, by using embedding similarity scores or another method (automated methods will likely be noisy, but noise is ok as long as it’s unbiased and equally noisy across different types of models that you’re testing against one another)Of course, N=100 is just an example, and in early stages, you might start with a smaller set that’s easier to generate, and in later stages, you might invest in a larger set that’s more costly but more statistically reliable.Scaling your solution architectureWhen designing your application or service for production that uses our API, it's important to consider how you will scale to meet traffic demands. There are a few key areas you will need to consider regardless of the cloud service provider of your choice:Horizontal scaling: You may want to scale your application out horizontally to accommodate requests to your application that come from multiple sources. This could involve deploying additional servers or containers to distribute the load. If you opt for this type of scaling, make sure that your architecture is designed to handle multiple nodes and that you have mechanisms in place to balance the load between them.Vertical scaling: Another option is to scale your application up vertically, meaning you can beef up the resources available to a single node. This would involve upgrading your server's capabilities to handle the additional load. If you opt for this type of scaling, make sure your application is designed to take advantage of these additional resources.Caching: By storing frequently accessed data, you can improve response times without needing to make repeated calls to our API. Your application will need to be designed to use cached data whenever possible and invalidate the cache when new information is added. There are a few different ways you could do this. For example, you could store data in a database, filesystem, or in-memory cache, depending on what makes the most sense for your application.Load balancing: Finally, consider load-balancing techniques to ensure requests are distributed evenly across your available servers. This could involve using a load balancer in front of your servers or using DNS round-robin. Balancing the load will help improve performance and reduce bottlenecks.Managing rate limitsWhen using our API, it's important to understand and plan for rate limits.Improving latenciesLatency is the time it takes for a request to be processed and a response to be returned. In this section, we will discuss some factors that influence the latency of our text generation models and provide suggestions on how to reduce it.The latency of a completion request is mostly influenced by two factors: the model and the number of tokens generated. The life cycle of a completion request looks like this:NetworkEnd user to API latencyServerTime to process prompt tokensServerTime to sample/generate tokensNetworkAPI to end user latencyThe bulk of the latency typically arises from the token generation step.Intuition: Prompt tokens add very little latency to completion calls. Time to generate completion tokens is much longer, as tokens are generated one at a time. Longer generation lengths will accumulate latency due to generation required for each token.Common factors affecting latency and possible mitigation techniquesNow that we have looked at the basics of latency, let’s take a look at various factors that can affect latency, broadly ordered from most impactful to least impactful.ModelOur API offers different models with varying levels of complexity and generality. The most capable models, such as gpt-4, can generate more complex and diverse completions, but they also take longer to process your query.\nModels such as gpt-3.5-turbo, can generate faster and cheaper chat completions, but they may generate results that are less accurate or relevant for your query. You can choose the model that best suits your use case and the trade-off between speed and quality.Number of completion tokensRequesting a large amount of generated tokens completions can lead to increased latencies:Lower max tokens: for requests with a similar token generation count, those that have a lower max_tokens parameter incur less latency.Include stop sequences: to prevent generating unneeded tokens, add a stop sequence. For example, you can use stop sequences to generate a list with a specific number of items. In this case, by using 11. as a stop sequence, you can generate a list with only 10 items, since the completion will stop when 11. is reached. Read our help article on stop sequences for more context on how you can do this.Generate fewer completions: lower the values of n and best_of when possible where n refers to how many completions to generate for each prompt and best_of is used to represent the result with the highest log probability per token.If n and best_of both equal 1 (which is the default), the number of generated tokens will be at most, equal to max_tokens.If n (the number of completions returned) or best_of (the number of completions generated for consideration) are set to > 1, each request will create multiple outputs. Here, you can consider the number of generated tokens as  [ max_tokens * max (n, best_of) ]StreamingSetting stream: true in a request makes the model start returning tokens as soon as they are available, instead of waiting for the full sequence of tokens to be generated. It does not change the time to get all the tokens, but it reduces the time for first token for an application where we want to show partial progress or are going to stop generations. This can be a better user experience and a UX improvement so it’s worth experimenting with streaming.InfrastructureOur servers are currently located in the US. While we hope to have global redundancy in the future, in the meantime you could consider locating the relevant parts of your infrastructure in the US to minimize the roundtrip time between your servers and the OpenAI servers.BatchingDepending on your use case, batching may help. If you are sending multiple requests to the same endpoint, you can batch the prompts to be sent in the same request. This will reduce the number of requests you need to make. The prompt parameter can hold up to 20 unique prompts. We advise you to test out this method and see if it helps. In some cases, you may end up increasing the number of generated tokens which will slow the response time.Managing costsTo monitor your costs, you can set a soft limit in your account to receive an email alert once you pass a certain usage threshold. You can also set a hard limit. Please be mindful of the potential for a hard limit to cause disruptions to your application/users. Use the usage tracking dashboard to monitor your token usage during the current and past billing cycles.Text generationOne of the challenges of moving your prototype into production is budgeting for the costs associated with running your application. OpenAI offers a pay-as-you-go pricing model, with prices per 1,000 tokens (roughly equal to 750 words). To estimate your costs, you will need to project the token utilization. Consider factors such as traffic levels, the frequency with which users will interact with your application, and the amount of data you will be processing.One useful framework for thinking about reducing costs is to consider costs as a function of the number of tokens and the cost per token. There are two potential avenues for reducing costs using this framework. First, you could work to reduce the cost per token by switching to smaller models for some tasks in order to reduce costs. Alternatively, you could try to reduce the number of tokens required. There are a few ways you could do this, such as by using shorter prompts, fine-tuning models, or caching common user queries so that they don't need to be processed repeatedly.You can experiment with our interactive tokenizer tool to help you estimate costs. The API and playground also returns token counts as part of the response. Once you’ve got things working with our most capable model, you can see if the other models can produce the same results with lower latency and costs. Learn more in our token usage help article.MLOps strategyAs you move your prototype into production, you may want to consider developing an MLOps strategy. MLOps (machine learning operations) refers to the process of managing the end-to-end life cycle of your machine learning models, including any models you may be fine-tuning using our API. There are a number of areas to consider when designing your MLOps strategy. These includeData and model management: managing the data used to train or fine-tune your model and tracking versions and changes.Model monitoring: tracking your model's performance over time and detecting any potential issues or degradation.Model retraining: ensuring your model stays up to date with changes in data or evolving requirements and retraining or fine-tuning it as needed.Model deployment: automating the process of deploying your model and related artifacts into production.Thinking through these aspects of your application will help ensure your model stays relevant and performs well over time.Security and complianceAs you move your prototype into production, you will need to assess and address any security and compliance requirements that may apply to your application. This will involve examining the data you are handling, understanding how our API processes data, and determining what regulations you must adhere to. For reference, here is our Privacy Policy and Terms of Use.Some common areas you'll need to consider include data storage, data transmission, and data retention. You might also need to implement data privacy protections, such as encryption or anonymization where possible. In addition, you should follow best practices for secure coding, such as input sanitization and proper error handling.Safety best practicesWhen creating your application with our API, consider our safety best practices to ensure your application is safe and successful. These recommendations highlight the importance of testing the product extensively, being proactive about addressing potential issues, and limiting opportunities for misuse.",
		"Safety best practicesUse our free Moderation APIOpenAI's Moderation API is free-to-use and can help reduce the frequency of unsafe content in your completions. Alternatively, you may wish to develop your own content filtration system tailored to your use case.Adversarial testingWe recommend “red-teaming” your application to ensure it's robust to adversarial input. Test your product over a wide range of inputs and user behaviors, both a representative set and those reflective of someone trying to ‘break' your application. Does it wander off topic? Can someone easily redirect the feature via prompt injections, e.g. “ignore the previous instructions and do this instead”?Human in the loop (HITL)Wherever possible, we recommend having a human review outputs before they are used in practice. This is especially critical in high-stakes domains, and for code generation. Humans should be aware of the limitations of the system, and have access to any information needed to verify the outputs (for example, if the application summarizes notes, a human should have easy access to the original notes to refer back).Prompt engineering“Prompt engineering” can help constrain the topic and tone of output text. This reduces the chance of producing undesired content, even if a user tries to produce it. Providing additional context to the model (such as by giving a few high-quality examples of desired behavior prior to the new input) can make it easier to steer model outputs in desired directions.“Know your customer” (KYC)Users should generally need to register and log-in to access your service. Linking this service to an existing account, such as a Gmail, LinkedIn, or Facebook log-in, may help, though may not be appropriate for all use-cases. Requiring a credit card or ID card reduces risk further.Constrain user input and limit output tokensLimiting the amount of text a user can input into the prompt helps avoid prompt injection. Limiting the number of output tokens helps reduce the chance of misuse.Narrowing the ranges of inputs or outputs, especially drawn from trusted sources, reduces the extent of misuse possible within an application.Allowing user inputs through validated dropdown fields (e.g., a list of movies on Wikipedia) can be more secure than allowing open-ended text inputs.Returning outputs from a validated set of materials on the backend, where possible, can be safer than returning novel generated content (for instance, routing a customer query to the best-matching existing customer support article, rather than attempting to answer the query from-scratch).Allow users to report issuesUsers should generally have an easily-available method for reporting improper functionality or other concerns about application behavior (listed email address, ticket submission method, etc). This method should be monitored by a human and responded to as appropriate.Understand and communicate limitationsFrom hallucinating inaccurate information, to offensive outputs, to bias, and much more, language models may not be suitable for every use case without significant modifications. Consider whether the model is fit for your purpose, and evaluate the performance of the API on a wide range of potential inputs in order to identify cases where the API's performance might drop. Consider your customer base and the range of inputs that they will be using, and ensure their expectations are calibrated appropriately. Safety and security are very important to us at OpenAI.If in the course of your development you do notice any safety or security issues with the API or anything else related to OpenAI, please submit these through our Coordinated Vulnerability Disclosure Program.End-user IDsSending end-user IDs in your requests can be a useful tool to help OpenAI monitor and detect abuse. This allows OpenAI to provide your team with more actionable feedback in the event that we detect any policy violations in your application.The IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. If you offer a preview of your product to non-logged in users, you can send a session ID instead.You can include end-user IDs in your API requests via the user parameter as follows:Example: Providing a user identiferpythonSelect librarypythoncurlCopy‍1\n2\n3\n4\n5\n6\nresponse = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=\"This is a test\",\n  max_tokens=5,\n  user=\"user123456\"\n)",
		"Error codesThis guide includes an overview on error codes you might see from  both the API and our official Python library. Each error code mentioned in the overview has a dedicated section with further guidance.API errorsCodeOverview401 - Invalid AuthenticationCause: Invalid Authentication  Solution: Ensure the correct API key and requesting organization are being used.401 - Incorrect API key providedCause: The requesting API key is not correct.  Solution: Ensure the API key used is correct, clear your browser cache, or generate a new one.401 - You must be a member of an organization to use the APICause: Your account is not part of an organization.  Solution: Contact us to get added to a new organization or ask your organization manager to invite you to an organization.429 - Rate limit reached for requestsCause: You are sending requests too quickly.  Solution: Pace your requests. Read the Rate limit guide.429 - You exceeded your current quota, please check your plan and billing detailsCause: You have hit your maximum monthly spend (hard limit) which you can view in the account billing section.  Solution: Apply for a quota increase.429 - The engine is currently overloaded, please try again laterCause: Our servers are experiencing high traffic.  Solution: Please retry your requests after a brief wait.500 - The server had an error while processing your requestCause: Issue on our servers.  Solution: Retry your request after a brief wait and contact us if the issue persists. Check the status page.401 - Invalid AuthenticationThis error message indicates that your authentication credentials are invalid. This could happen for several reasons, such as:You are using a revoked API key.You are using a different API key than the one assigned to the requesting organization.You are using an API key that does not have the required permissions for the endpoint you are calling.To resolve this error, please follow these steps:Check that you are using the correct API key and organization ID in your request header. You can find your API key and organization ID in your account settings.If you are unsure whether your API key is valid, you can generate a new one. Make sure to replace your old API key with the new one in your requests and follow our best practices guide.Collapse‍401 - Incorrect API key providedThis error message indicates that the API key you are using in your request is not correct. This could happen for several reasons, such as:There is a typo or an extra space in your API key.You are using an API key that belongs to a different organization.You are using an API key that has been deleted or deactivated.An old, revoked API key might be cached locally.To resolve this error, please follow these steps:Try clearing your browser's cache and cookies, then try again.Check that you are using the correct API key in your request header.If you are unsure whether your API key is correct, you can generate a new one. Make sure to replace your old API key in your codebase and follow our best practices guide.Collapse‍401 - You must be a member of an organization to use the APIThis error message indicates that your account is not part of an organization. This could happen for several reasons, such as:You have left or been removed from your previous organization.Your organization has been deleted.To resolve this error, please follow these steps:If you have left or been removed from your previous organization, you can either request a new organization or get invited to an existing one.To request a new organization, reach out to us via help.openai.comExisting organization owners can invite you to join their organization via the Members Panel.Collapse‍429 - Rate limit reached for requestsThis error message indicates that you have hit your assigned rate limit for the API. This means that you have submitted too many tokens or requests in a short period of time and have exceeded the number of requests allowed. This could happen for several reasons, such as:You are using a loop or a script that makes frequent or concurrent requests.You are sharing your API key with other users or applications.You are using a free plan that has a low rate limit.To resolve this error, please follow these steps:Pace your requests and avoid making unnecessary or redundant calls.If you are using a loop or a script, make sure to implement a backoff mechanism or a retry logic that respects the rate limit and the response headers. You can read more about our rate limiting policy and best practices in our rate limit guide.If you are sharing your organization with other users, note that limits are applied per organization and not per user. It is worth checking on the usage of the rest of your team as this will contribute to the limit.If you are using a free or low-tier plan, consider upgrading to a pay-as-you-go plan that offers a higher rate limit. You can compare the restrictions of each plan in our rate limit guide.Collapse‍429 - You exceeded your current quota, please check your plan and billing detailsThis error message indicates that you have hit your maximum monthly spend for the API. You can view your maximum monthly limit, under ‘hard limit’ in your [account billing settings](/account/billing/limits). This means that you have consumed all the credits allocated to your plan and have reached the limit of your current billing cycle. This could happen for several reasons, such as:You are using a high-volume or complex service that consumes a lot of credits or tokens.Your limit is set too low for your organization’s usage.To resolve this error, please follow these steps:Check your current quota in your account settings. You can see how many tokens your requests have consumed in the usage section of your account.If you are using a free plan, consider upgrading to a pay-as-you-go plan that offers a higher quota.If you need a quota increase, you can apply for one and provide relevant details on expected usage. We will review your request and get back to you in ~7-10 business days.Collapse‍429 - The engine is currently overloaded, please try again laterThis error message indicates that our servers are experiencing high traffic and are unable to process your request at the moment. This could happen for several reasons, such as:There is a sudden spike or surge in demand for our services.There is scheduled or unscheduled maintenance or update on our servers.There is an unexpected or unavoidable outage or incident on our servers.To resolve this error, please follow these steps:Retry your request after a brief wait. We recommend using an exponential backoff strategy or a retry logic that respects the response headers and the rate limit. You can read more about our rate limit best practices.Check our status page for any updates or announcements regarding our services and servers.If you are still getting this error after a reasonable amount of time, please contact us for further assistance. We apologize for any inconvenience and appreciate your patience and understanding.Collapse‍Python library error typesTypeOverviewAPIErrorCause:  Issue on our side.  Solution: Retry your request after a brief wait and contact us if the issue persists.TimeoutCause:   Request timed out.  Solution: Retry your request after a brief wait and contact us if the issue persists.RateLimitErrorCause: You have hit your assigned rate limit.   Solution: Pace your requests. Read more in our Rate limit guide.APIConnectionErrorCause: Issue connecting to our services.  Solution: Check your network settings, proxy configuration, SSL certificates, or firewall rules.InvalidRequestErrorCause: Your request was malformed or missing some required parameters, such as a token or an input.  Solution: The error message should advise you on the specific error made. Check the documentation for the specific API method you are calling and make sure you are sending valid and complete parameters. You may also need to check the encoding, format, or size of your request data.AuthenticationErrorCause: Your API key or token was invalid, expired, or revoked.  Solution: Check your API key or token and make sure it is correct and active. You may need to generate a new one from your account dashboard.ServiceUnavailableErrorCause: Issue on our servers.  Solution: Retry your request after a brief wait and contact us if the issue persists. Check the status page.APIErrorAn `APIError` indicates that something went wrong on our side when processing your request. This could be due to a temporary error, a bug, or a system outage.We apologize for any inconvenience and we are working hard to resolve any issues as soon as possible. You can check our system status page for more information.If you encounter an APIError, please try the following steps:Wait a few seconds and retry your request. Sometimes, the issue may be resolved quickly and your request may succeed on the second attempt.Check our status page for any ongoing incidents or maintenance that may affect our services. If there is an active incident, please follow the updates and wait until it is resolved before retrying your request.If the issue persists,  check out our Persistent errors next steps section.Our support team will investigate the issue and get back to you as soon as possible. Note that our support queue times may be long due to high demand. You can also post in our Community Forum but be sure to omit any sensitive information.Collapse‍TimeoutA `Timeout` error indicates that your request took too long to complete and our server closed the connection. This could be due to a network issue, a heavy load on our services, or a complex request that requires more processing time.If you encounter a Timeout error, please try the following steps:Wait a few seconds and retry your request. Sometimes, the network congestion or the load on our services may be reduced and your request may succeed on the second attempt.Check your network settings and make sure you have a stable and fast internet connection. You may need to switch to a different network, use a wired connection, or reduce the number of devices or applications using your bandwidth.If the issue persists,  check out our persistent errors next steps section.Collapse‍RateLimitErrorA `RateLimitError` indicates that you have hit your assigned rate limit. This means that you have sent too many tokens or requests in a given period of time, and our services have temporarily blocked you from sending more.We impose rate limits to ensure fair and efficient use of our resources and to prevent abuse or overload of our services.If you encounter a RateLimitError, please try the following steps:Send fewer tokens or requests or slow down. You may need to reduce the frequency or volume of your requests, batch your tokens, or implement exponential backoff. You can read our Rate limit guide for more details.Wait until your rate limit resets (one minute) and retry your request. The error message should give you a sense of your usage rate and permitted usage.You can also check your API usage statistics from your account dashboard.Collapse‍APIConnectionErrorAn `APIConnectionError` indicates that your request could not reach our servers or establish a secure connection. This could be due to a network issue, a proxy configuration, an SSL certificate, or a firewall rule.If you encounter an APIConnectionError, please try the following steps:Check your network settings and make sure you have a stable and fast internet connection. You may need to switch to a different network, use a wired connection, or reduce the number of devices or applications using your bandwidth.Check your proxy configuration and make sure it is compatible with our services. You may need to update your proxy settings, use a different proxy, or bypass the proxy altogether.Check your SSL certificates and make sure they are valid and up-to-date. You may need to install or renew your certificates, use a different certificate authority, or disable SSL verification.Check your firewall rules and make sure they are not blocking or filtering our services. You may need to modify your firewall settings.If appropriate, check that your container has the correct permissions to send and receive traffic.If the issue persists,  check out our persistent errors next steps section.Collapse‍InvalidRequestErrorAn InvalidRequestError indicates that your request was malformed or missing some required parameters, such as a token or an input. This could be due to a typo, a formatting error, or a logic error in your code.If you encounter an InvalidRequestError, please try the following steps:Read the error message carefully and identify the specific error made. The error message should advise you on what parameter was invalid or missing, and what value or format was expected.Check the API Reference for the specific API method you were calling and make sure you are sending valid and complete parameters. You may need to review the parameter names, types, values, and formats, and ensure they match the documentation.Check the encoding, format, or size of your request data and make sure they are compatible with our services. You may need to encode your data in UTF-8, format your data in JSON, or compress your data if it is too large.Test your request using a tool like Postman or curl and make sure it works as expected. You may need to debug your code and fix any errors or inconsistencies in your request logic.If the issue persists,  check out our persistent errors next steps section.Collapse‍AuthenticationErrorAn `AuthenticationError` indicates that your API key or token was invalid, expired, or revoked. This could be due to a typo, a formatting error, or a security breach.If you encounter an AuthenticationError, please try the following steps:Check your API key or token and make sure it is correct and active. You may need to generate a new key from the API Key dashboard, ensure there are no extra spaces or characters, or use a different key or token if you have multiple ones.Ensure that you have followed the correct formatting.Collapse‍ServiceUnavailableErrorA `ServiceUnavailableError` indicates that our servers are temporarily unable to handle your request. This could be due to a planned or unplanned maintenance, a system upgrade, or a server failure. These errors can also be returned during periods of high traffic.We apologize for any inconvenience and we are working hard to restore our services as soon as possible.If you encounter a ServiceUnavailableError, please try the following steps:Wait a few minutes and retry your request. Sometimes, the issue may be resolved quickly and your request may succeed on the next attempt.Check our status page for any ongoing incidents or maintenance that may affect our services. If there is an active incident, please follow the updates and wait until it is resolved before retrying your request.If the issue persists, check out our persistent errors next steps section.Collapse‍Persistent errorsIf the issue persists, contact our support team via chat and provide them with the following information:The model you were usingThe error message and code you receivedThe request data and headers you sentThe timestamp and timezone of your requestAny other relevant details that may help us diagnose the issueOur support team will investigate the issue and get back to you as soon as possible. Note that our support queue times may be long due to high demand. You can also post in our Community Forum but be sure to omit any sensitive information.Handling errorsWe advise you to programmatically handle errors returned by the API. To do so, you may want to use a code snippet like below:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\ntry:\n  #Make your OpenAI API request here\n  response = openai.Completion.create(prompt=\"Hello world\",\n                                      model=\"text-davinci-003\")\nexcept openai.error.APIError as e:\n  #Handle API error here, e.g. retry or log\n  print(f\"OpenAI API returned an API Error: {e}\")\n  pass\nexcept openai.error.APIConnectionError as e:\n  #Handle connection error here\n  print(f\"Failed to connect to OpenAI API: {e}\")\n  pass\nexcept openai.error.RateLimitError as e:\n  #Handle rate limit error (we recommend using exponential backoff)\n  print(f\"OpenAI API request exceeded rate limit: {e}\")\n  pass",
		"Rate limitsOverviewWhat are rate limits?A rate limit is a restriction that an API imposes on the number of times a user or client can access the server within a specified period of time. Why do we have rate limits?Rate limits are a common practice for APIs, and they're put in place for a few different reasons:They help protect against abuse or misuse of the API. For example, a malicious actor could flood the API with requests in an attempt to overload it or cause disruptions in service. By setting rate limits, OpenAI can prevent this kind of activity.Rate limits help ensure that everyone has fair access to the API. If one person or organization makes an excessive number of requests, it could bog down the API for everyone else. By throttling the number of requests that a single user can make, OpenAI ensures that the most number of people have an opportunity to use the API without experiencing slowdowns.Rate limits can help OpenAI manage the aggregate load on its infrastructure. If requests to the API increase dramatically, it could tax the servers and cause performance issues. By setting rate limits, OpenAI can help maintain a smooth and consistent experience for all users.Please work through this document in its entirety to better understand how OpenAI’s rate limit system works. We include code examples and possible solutions to handle common issues. It is recommended to follow this guidance before filling out the Rate Limit Increase Request form with details regarding how to fill it out in the last section.What are the rate limits for our API?We enforce rate limits at the organization level, not user level, based on the specific endpoint used as well as the type of account you have. Rate limits are measured in two ways: RPM (requests per minute) and TPM (tokens per minute). The table below highlights the default rate limits for our API but these limits can be increased depending on your use case after filling out the Rate Limit increase request form.The TPM (tokens per minute) unit is different depending on the model:type1 TPM equalsdavinci1 token per minutecurie25 tokens per minutebabbage100 tokens per minuteada200 tokens per minuteIn practical terms, this means you can send approximately 200x more tokens per minute to an ada model versus a davinci model.Text & EmbeddingChatCodexEditImageAudioFree trial users3 RPM  150,000 TPM3 RPM  40,000 TPM3 RPM  40,000 TPM3 RPM  150,000 TPM5 images / min3 RPMPay-as-you-go users (first 48 hours)60 RPM  250,000 TPM60 RPM  60,000 TPM20 RPM  40,000 TPM20 RPM  150,000 TPM50 images / min50 RPMPay-as-you-go users (after 48 hours)3,500 RPM  350,000 TPM3,500 RPM  90,000 TPM20 RPM  40,000 TPM20 RPM  150,000 TPM50 images / min50 RPMIt is important to note that the rate limit can be hit by either option depending on what occurs first. For example, you might send 20 requests with only 100 tokens to the Codex endpoint and that would fill your limit, even if you did not send 40k tokens within those 20 requests.GPT-4 rate limitsDuring the limited beta rollout of GPT-4, the model will have more aggressive rate limits to keep up with demand. Default rate limits for gpt-4/gpt-4-0314 are 40k TPM and 200 RPM. Default rate limits for  gpt-4-32k/gpt-4-32k-0314 are 80k TPM and 400 RPM. We are unable to accommodate requests for rate limit increases due to capacity constraints. In its current state, the model is intended for experimentation and prototyping, not high volume production use cases.How do rate limits work?If your rate limit is 60 requests per minute and 150k davinci tokens per minute, you’ll be limited either by reaching the requests/min cap or running out of tokens—whichever happens first. For example, if your max requests/min is 60, you should be able to send 1 request per second. If you send 1 request every 800ms, once you hit your rate limit, you’d only need to make your program sleep 200ms in order to send one more request otherwise subsequent requests would fail. With the default of 3,000 requests/min, customers can effectively send 1 request every 20ms, or every .02 seconds.What happens if I hit a rate limit error?Rate limit errors look like this: Rate limit reached for default-text-davinci-002 in organization org-{id} on requests per min. Limit: 20.000000 / min. Current: 24.000000 / min.If you hit a rate limit, it means you've made too many requests in a short period of time, and the API is refusing to fulfill further requests until a specified amount of time has passed.Rate limits vs max_tokensEach model we offer has a limited number of tokens that can be passed in as input when making a request. You cannot increase the maximum number of tokens a model takes in. For example, if you are using text-ada-001, the maximum number of tokens you can send to this model is 2,048 tokens per request.Error MitigationWhat are some steps I can take to mitigate this?The OpenAI Cookbook has a python notebook that explains details on how to avoid rate limit errors.You should also exercise caution when providing programmatic access, bulk processing features, and automated social media posting - consider only enabling these for trusted customers. To protect against automated and high-volume misuse, set a usage limit for individual users within a specified time frame (daily, weekly, or monthly). Consider implementing a hard cap or a manual review process for users who exceed the limit. Retrying with exponential backoffOne easy way to avoid rate limit errors is to automatically retry requests with a random exponential backoff. Retrying with exponential backoff means performing a short sleep when a rate limit error is hit, then retrying the unsuccessful request. If the request is still unsuccessful, the sleep length is increased and the process is repeated. This continues until the request is successful or until a maximum number of retries is reached.\nThis approach has many benefits:Automatic retries means you can recover from rate limit errors without crashes or missing dataExponential backoff means that your first retries can be tried quickly, while still benefiting from longer delays if your first few retries failAdding random jitter to the delay helps retries from all hitting at the same time.Note that unsuccessful requests contribute to your per-minute limit, so continuously resending a request won’t work.Below are a few example solutions for Python that use exponential backoff.Example #1: Using the Tenacity libraryTenacity is an Apache 2.0 licensed general-purpose retrying library, written in Python, to simplify the task of adding retry behavior to just about anything.\nTo add exponential backoff to your requests, you can use the tenacity.retry decorator. The below example uses the tenacity.wait_random_exponential function to add random exponential backoff to a request.Using the Tenacity librarypythonSelect librarypythonCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nimport openai\nfrom tenacity import (\n    retry,\n    stop_after_attempt,\n    wait_random_exponential,\n)  # for exponential backoff\n \n@retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(6))\ndef completion_with_backoff(**kwargs):\n    return openai.Completion.create(**kwargs)\n \ncompletion_with_backoff(model=\"text-davinci-003\", prompt=\"Once upon a time,\")Note that the Tenacity library is a third-party tool, and OpenAI makes no guarantees about its reliability or security.Collapse‍Example #2: Using the backoff libraryAnother python library that provides function decorators for backoff and retry is backoff:Using the Tenacity librarypythonSelect librarypythonCopy‍1\n2\n3\n4\n5\n6\n7\nimport backoff \nimport openai \n@backoff.on_exception(backoff.expo, openai.error.RateLimitError)\ndef completions_with_backoff(**kwargs):\n    return openai.Completion.create(**kwargs)\n \ncompletions_with_backoff(model=\"text-davinci-003\", prompt=\"Once upon a time,\")Like Tenacity, the backoff library is a third-party tool, and OpenAI makes no guarantees about its reliability or security.Collapse‍Example 3: Manual backoff implementationIf you don't want to use third-party libraries, you can implement your own backoff logic following this example:Using manual backoff implementationpythonSelect librarypythonCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n# imports\nimport random\nimport time\n \nimport openai\n \n# define a retry decorator\ndef retry_with_exponential_backoff(\n    func,\n    initial_delay: float = 1,\n    exponential_base: float = 2,\n    jitter: bool = True,\n    max_retries: int = 10,\n    errors: tuple = (openai.error.RateLimitError,),\n):\n    \"\"\"Retry a function with exponential backoff.\"\"\"\n \n    def wrapper(*args, **kwargs):\n        # Initialize variables\n        num_retries = 0\n        delay = initial_delay\n \n        # Loop until a successful response or max_retries is hit or an exception is raised\n        while True:\n            try:\n                return func(*args, **kwargs)\n \n            # Retry on specific errors\n            except errors as e:\n                # Increment retries\n                num_retries += 1\n \n                # Check if max retries has been reached\n                if num_retries > max_retries:\n                    raise Exception(\n                        f\"Maximum number of retries ({max_retries}) exceeded.\"\n                    )\n \n                # Increment the delay\n                delay *= exponential_base * (1 + jitter * random.random())\n \n                # Sleep for the delay\n                time.sleep(delay)\n \n            # Raise exceptions for any errors not specified\n            except Exception as e:\n                raise e\n \n    return wrapper\n    \n@retry_with_exponential_backoff\ndef completions_with_backoff(**kwargs):\n    return openai.Completion.create(**kwargs)Again, OpenAI makes no guarantees on the security or efficiency of this solution but it can be a good starting place for your own solution.Collapse‍Batching requestsThe OpenAI API has separate limits for requests per minute and tokens per minute. If you're hitting the limit on requests per minute, but have available capacity on tokens per minute, you can increase your throughput by batching multiple tasks into each request. This will allow you to process more tokens per minute, especially with our smaller models.Sending in a batch of prompts works exactly the same as a normal API call, except you pass in a list of strings to the prompt parameter instead of a single string.Example without batchingNo batchingpythonSelect librarypythonCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nimport openai\n \nnum_stories = 10\nprompt = \"Once upon a time,\"\n \n# serial example, with one story completion per request\nfor _ in range(num_stories):\n    response = openai.Completion.create(\n        model=\"curie\",\n        prompt=prompt,\n        max_tokens=20,\n    )\n    # print story\n    print(prompt + response.choices[0].text)Collapse‍Example with batchingBatchingpythonSelect librarypythonCopy‍1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport openai  # for making OpenAI API requests\n \n \nnum_stories = 10\nprompts = [\"Once upon a time,\"] * num_stories\n \n# batched example, with 10 story completions per request\nresponse = openai.Completion.create(\n    model=\"curie\",\n    prompt=prompts,\n    max_tokens=20,\n)\n \n# match completions to prompts by index\nstories = [\"\"] * len(prompts)\nfor choice in response.choices:\n    stories[choice.index] = prompts[choice.index] + choice.text\n \n# print stories\nfor story in stories:\n    print(story)Collapse‍ Warning: the response object may not return completions in the order of the prompts, so always remember to match responses back to prompts using the index field.Request IncreaseWhen should I consider applying for a rate limit increase?Our default rate limits help us maximize stability and prevent abuse of our API. We increase limits to enable high-traffic applications, so the best time to apply for a rate limit increase is when you feel that you have the necessary traffic data to support a strong case for increasing the rate limit. Large rate limit increase requests without supporting data are not likely to be approved. If you're gearing up for a product launch, please obtain the relevant data through a phased release over 10 days.Keep in mind that rate limit increases can sometimes take 7-10 days so it makes sense to try and plan ahead and submit early if there is data to support you will reach your rate limit given your current growth numbers.Will my rate limit increase request be rejected?A rate limit increase request is most often rejected because it lacks the data needed to justify the increase. We have provided numerical examples below that show how to best support a rate limit increase request and try our best to approve all requests that align with our safety policy and show supporting data. We are committed to enabling developers to scale and be successful with our API.I’ve implemented exponential backoff for my text/code APIs, but I’m still hitting this error. How do I increase my rate limit?We understand the frustration that limited rate limits can cause, and we would love to raise the defaults for everyone. However, due to shared capacity constraints, we can only approve rate limit increases for paid customers who have demonstrated a need through our Rate Limit Increase Request form.\nTo help us evaluate your needs properly, we ask that you please provide statistics on your current usage or projections based on historic user activity in the 'Share evidence of need' section of the form. If this information is not available, we recommend a phased release approach. Start by releasing the service to a subset of users at your current rate limits, gather usage data for 10 business days, and then submit a formal rate limit increase request based on that data for our review and approval.We will review your request and if it is approved, we will notify you of the approval within a period of 7-10 business days.Here are some examples of how you might fill out this form:DALL-E API examplesModelEstimate Tokens/MinuteEstimate Requests/Minute# of usersEvidence of need1 hour max throughput costDALL-E APIN/A501000Our app is currently in production and based on our past traffic, we make about 10 requests per minute.$60DALL-E APIN/A15010,000Our app is gaining traction in the App Store and we’re starting to hit rate limits. Can we get triple the default limit of 50 img/min? If we need more we’ll submit a new form. Thanks!$180Collapse‍Language model examplesModelEstimate Tokens/MinuteEstimate Requests/Minute# of usersEvidence of need1 hour max throughput costtext-davinci-003325,0004,00050We’re releasing to an initial group of alpha testers and need a higher limit to accommodate their initial usage. We have a link here to our google drive which shows analytics and api usage.$390text-davinci-002750,00010,00010,000Our application is receiving a lot of interest; we have 50,000 people on our waitlist. We’d like to roll out to groups of 1,000 people/day until we reach 50,000 users. Please see this link of our current token/minute traffic over the past 30 days. This is for 500 users, and based on their usage, we think 750,000 tokens/minute and 10,000 requests/minute will work as a good starting point.$900Collapse‍Code model examplesModelEstimate Tokens/MinuteEstimate Requests/Minute# of usersEvidence of need1 hour max throughput costcode-davinci-002150,0001,00015We are a group of researchers working on a paper. We estimate that we will need a higher rate limit on code-davinci-002 in order to complete our research before the end of the month. These estimates are based on the following calculation [...]Codex models are currently in free beta so we may not be able to provide immediate increases for these models.Collapse‍Please note that these examples are just general use case scenarios, the actual usage rate will vary depending on the specific implementation and usage.",
		"ModerationOverviewThe moderation endpoint is a tool you can use to check whether content complies with OpenAI's usage policies. Developers can thus identify content that our usage policies prohibits and take action, for instance by filtering it.The models classifies the following categories:CategoryDescriptionhateContent that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.hate/threateningHateful content that also includes violence or serious harm towards the targeted group.self-harmContent that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.sexualContent meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).sexual/minorsSexual content that includes an individual who is under 18 years old.violenceContent that promotes or glorifies violence or celebrates the suffering or humiliation of others.violence/graphicViolent content that depicts death, violence, or serious physical injury in extreme graphic detail.The moderation endpoint is free to use when monitoring the inputs and outputs of OpenAI APIs. We currently do not support monitoring of third-party traffic.We are continuously working to improve the accuracy of our classifier and are especially working to improve the classifications of hate, self-harm, and violence/graphic content. Our support for non-English languages is currently limited.QuickstartTo obtain a classification for a piece of text, make a request to the moderation endpoint as demonstrated in the following code snippets:Example: Getting moderationscurlSelect librarypythoncurlCopy‍1\n2\n3\n4\n5\ncurl https://api.openai.com/v1/moderations \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\"input\": \"Sample text goes here\"}'Below is an example output of the endpoint. It returns the following fields:flagged: Set to true if the model classifies the content as violating OpenAI's usage policies, false otherwise.categories: Contains a dictionary of per-category binary usage policies violation flags. For each category, the value is true if the model flags the corresponding category as violated, false otherwise.category_scores: Contains a dictionary of per-category raw scores output by the model, denoting the model's confidence that the input violates the OpenAI's policy for the category. The value is between 0 and 1, where higher values denote higher confidence. The scores should not be interpreted as probabilities.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n{\n  \"id\": \"modr-XXXXX\",\n  \"model\": \"text-moderation-001\",\n  \"results\": [\n    {\n      \"categories\": {\n        \"hate\": false,\n        \"hate/threatening\": false,\n        \"self-harm\": false,\n        \"sexual\": false,\n        \"sexual/minors\": false,\n        \"violence\": false,\n        \"violence/graphic\": false\n      },\n      \"category_scores\": {\n        \"hate\": 0.18805529177188873,\n        \"hate/threatening\": 0.0001250059431185946,\n        \"self-harm\": 0.0003706029092427343,\n        \"sexual\": 0.0008735615410842001,\n        \"sexual/minors\": 0.0007470346172340214,\n        \"violence\": 0.0041268812492489815,\n        \"violence/graphic\": 0.00023186142789199948\n      },\n      \"flagged\": false\n    }\n  ]\n}OpenAI will continuously upgrade the moderation endpoint's underlying model. Therefore, custom policies that rely on category_scores may need recalibration over time.",
		"Speech to text BetaLearn how to turn audio into textIntroductionThe speech to text API provides two endpoints, transcriptions and translations, based on our state-of-the-art open source large-v2 Whisper model. They can be used to: Transcribe audio into whatever language the audio is in.Translate and transcribe the audio into english.File uploads are currently limited to 25 MB and the following input file types are supported: mp3, mp4, mpeg, mpga, m4a, wav, and webm.QuickstartTranscriptionsThe transcriptions API takes as input the audio file you want to transcribe and the desired output file format for the transcription of the audio. We currently support multiple input and output file formats.Transcribe audiopythonSelect librarypythoncurlCopy‍1\n2\n3\n4\n# Note: you need to be using OpenAI Python v0.27.0 for the code below to work\nimport openai\naudio_file= open(\"/path/to/file/audio.mp3\", \"rb\")\ntranscript = openai.Audio.transcribe(\"whisper-1\", audio_file)By default, the response type will be json with the raw text included.{\n  \"text\": \"Imagine the wildest idea that you've ever had, and you're curious about how it might scale to something that's a 100, a 1,000 times bigger.\n....\n}To set additional parameters in a request, you can add more --form lines with the relevant options. For example, if you want to set the output format as text, you would add the following line:1\n2\n3\n4\n...\n--form file=@openai.mp3 \\\n--form model=whisper-1 \\\n--form response_format=textTranslationsThe translations API takes as input the audio file in any of the supported languages and transcribes, if necessary, the audio into english. This differs from our /Transcriptions endpoint since the output is not in the original input language and is instead translated to english text.Translate audiopythonSelect librarypythoncurlCopy‍1\n2\n3\n4\n# Note: you need to be using OpenAI Python v0.27.0 for the code below to work\nimport openai\naudio_file= open(\"/path/to/file/german.mp3\", \"rb\")\ntranscript = openai.Audio.translate(\"whisper-1\", audio_file)In this case, the inputted audio was german and the outputted text looks like: Hello, my name is Wolfgang and I come from Germany. Where are you heading today?We only support translation into english at this time.Supported languagesWe currently support the following languages through both the transcriptions and translations endpoint:Afrikaans, Arabic, Armenian, Azerbaijani, Belarusian, Bosnian, Bulgarian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Estonian, Finnish, French, Galician, German, Greek, Hebrew, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Kannada, Kazakh, Korean, Latvian, Lithuanian, Macedonian, Malay, Marathi, Maori, Nepali, Norwegian, Persian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovenian, Spanish, Swahili, Swedish, Tagalog, Tamil, Thai, Turkish, Ukrainian, Urdu, Vietnamese, and Welsh.While the underlying model was trained on 98 languages, we only list the languages that exceeded <50% word error rate (WER) which is an industry standard benchmark for speech to text model accuracy. The model will return results for languages not listed above but the quality will be low.Longer inputsBy default, the Whisper API only supports files that are less than 25 MB. If you have an audio file that is longer than that, you will need to break it up into chunks of 25 MB's or less or used a compressed audio format. To get the best performance, we suggest that you avoid breaking the audio up mid-sentence as this may cause some context to be lost.One way to handle this is to use the PyDub open source Python package to split the audio:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nfrom pydub import AudioSegment\n\nsong = AudioSegment.from_mp3(\"good_morning.mp3\")\n\n# PyDub handles time in milliseconds\nten_minutes = 10 * 60 * 1000\n\nfirst_10_minutes = song[:ten_minutes]\n\nfirst_10_minutes.export(\"good_morning_10.mp3\", format=\"mp3\")OpenAI makes no guarantees about the usability or security of 3rd party software like PyDub.PromptingYou can use a prompt to improve the quality of the transcripts generated by the Whisper API. The model will try to match the style of the prompt, so it will be more likely to use capitalization and punctuation if the prompt does too. However, the current prompting system is much more limited than our other language models and only provides limited control over the generated audio. Here are some examples of how prompting can help in different scenarios:Prompts can be very helpful for correcting specific words or acronyms that the model often misrecognizes in the audio. For example, the following prompt improves the transcription of the words DALL·E and GPT-3, which were previously written as \"GDP 3\" and \"DALI\".The transcript is about OpenAI which makes technology like DALL·E, GPT-3, and ChatGPT with the hope of one day building an AGI system that benefits all of humanityTo preserve the context of a file that was split into segments, you can prompt the model with the transcript of the preceding segment. This will make the transcript more accurate, as the model will use the relevant information from the previous audio. The model will only consider the final 224 tokens of the prompt and ignore anything earlier.Sometimes the model might skip punctuation in the transcript. You can avoid this by using a simple prompt that includes punctuation:Hello, welcome to my lecture.The model may also leave out common filler words in the audio. If you want to keep the filler words in your transcript, you can use a prompt that contains them:Umm, let me think like, hmm... Okay, here's what I'm, like, thinking.\"Some languages can be written in different ways, such as simplified or traditional Chinese. The model might not always use the writing style that you want for your transcript by default. You can improve this by using a prompt in your preferred writing style.",
		"EmbeddingsWhat are embeddings?OpenAI’s text embeddings measure the relatedness of text strings. Embeddings are commonly used for:Search (where results are ranked by relevance to a query string)Clustering (where text strings are grouped by similarity)Recommendations (where items with related text strings are recommended)Anomaly detection (where outliers with little relatedness are identified)Diversity measurement (where similarity distributions are analyzed)Classification (where text strings are classified by their most similar label)An embedding is a vector (list) of floating point numbers. The distance between two vectors measures their relatedness. Small distances suggest high relatedness and large distances suggest low relatedness.Visit our pricing page to learn about Embeddings pricing. Requests are billed based on the number of tokens in the input sent.To see embeddings in action, check out our code samplesClassificationTopic clusteringSearchRecommendationsBrowse Samples‍How to get embeddingsTo get an embedding, send your text string to the embeddings API endpoint along with a choice of embedding model ID (e.g., text-embedding-ada-002). The response will contain an embedding, which you can extract, save, and use.Example requests:Example: Getting embeddingscurlSelect librarypythoncurlCopy‍1\n2\n3\n4\n5\n6\n7\ncurl https://api.openai.com/v1/embeddings \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"input\": \"Your text string goes here\",\n    \"model\": \"text-embedding-ada-002\"\n  }'Example response:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"data\": [\n    {\n      \"embedding\": [\n        -0.006929283495992422,\n        -0.005336422007530928,\n        ...\n        -4.547132266452536e-05,\n        -0.024047505110502243\n      ],\n      \"index\": 0,\n      \"object\": \"embedding\"\n    }\n  ],\n  \"model\": \"text-embedding-ada-002\",\n  \"object\": \"list\",\n  \"usage\": {\n    \"prompt_tokens\": 5,\n    \"total_tokens\": 5\n  }\n}See more Python code examples in the OpenAI Cookbook.When using OpenAI embeddings, please keep in mind their limitations and risks.Embedding modelsOpenAI offers one second-generation embedding model (denoted by -002 in the model ID) and 16 first-generation models (denoted by -001 in the model ID).We recommend using text-embedding-ada-002 for nearly all use cases. It’s better, cheaper, and simpler to use. Read the blog post announcement.Model generationtokenizermax input tokensknowledge cutoffV2cl100k_base8191Sep 2021V1GPT-2/GPT-32046Aug 2020Usage is priced per input token, at a rate of $0.0004 per 1000 tokens, or about ~3,000 pages per US dollar (assuming ~800 tokens per page):ModelRough pages per dollarExample performance on BEIR search evaltext-embedding-ada-002300053.9*-davinci-*-001652.8*-curie-*-0016050.9*-babbage-*-00124050.4*-ada-*-00130049.0Second-generation modelsModel nametokenizermax input tokensoutput dimensionstext-embedding-ada-002cl100k_base81911536First-generation models (not recommended)All first-generation models (those ending in -001) use the GPT-3 tokenizer and have a max input of 2046 tokens.First-generation embeddings are generated by five different model families tuned for three different tasks: text search, text similarity and code search. The search models come in pairs: one for short queries and one for long documents. Each family includes up to four models on a spectrum of quality and speed:Modeloutput dimensionsAda1024Babbage2048Curie4096Davinci12288Davinci is the most capable, but is slower and more expensive than the other models. Ada is the least capable, but is significantly faster and cheaper.Similarity embeddingsSimilarity models are best at capturing semantic similarity between pieces of text.Use casesAvailable modelsClustering, regression, anomaly detection, visualizationtext-similarity-ada-001text-similarity-babbage-001text-similarity-curie-001 text-similarity-davinci-001Text search embeddingsText search models help measure which long documents are most relevant to a short search query. Two models are used: one for embedding the search query and one for embedding the documents to be ranked. The document embeddings closest to the query embedding should be the most relevant.Use casesAvailable modelsSearch, context relevance, information retrievaltext-search-ada-doc-001text-search-ada-query-001text-search-babbage-doc-001text-search-babbage-query-001text-search-curie-doc-001text-search-curie-query-001text-search-davinci-doc-001text-search-davinci-query-001Code search embeddingsSimilarly to search embeddings, there are two types: one for embedding natural language search queries and one for embedding code snippets to be retrieved.Use casesAvailable modelsCode search and relevancecode-search-ada-code-001code-search-ada-text-001code-search-babbage-code-001code-search-babbage-text-001With the -001 text embeddings (not -002, and not code embeddings), we suggest replacing newlines (\\n) in your input with a single space, as we have seen worse results when newlines are present.Collapse‍Use casesHere we show some representative use cases. We will use the Amazon fine-food reviews dataset for the following examples.Obtaining the embeddingsThe dataset contains a total of 568,454 food reviews Amazon users left up to October 2012. We will use a subset of 1,000 most recent reviews for illustration purposes. The reviews are in English and tend to be positive or negative. Each review has a ProductId, UserId, Score, review title (Summary) and review body (Text). For example:Product IdUser IdScoreSummaryTextB001E4KFG0A3SGXH7AUHU8GW5Good Quality Dog FoodI have bought several of the Vitality canned...B00813GRG4A1D87F6ZCVE5NK1Not as AdvertisedProduct arrived labeled as Jumbo Salted Peanut...We will combine the review summary and review text into a single combined text. The model will encode this combined text and output a single vector embedding.Obtain_dataset.ipynb1\n2\n3\n4\n5\n6\ndef get_embedding(text, model=\"text-embedding-ada-002\"):\n   text = text.replace(\"\\n\", \" \")\n   return openai.Embedding.create(input = [text], model=model)['data'][0]['embedding']\n\ndf['ada_embedding'] = df.combined.apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\ndf.to_csv('output/embedded_1k_reviews.csv', index=False)To load the data from a saved file, you can run the following:1\n2\n3\n4\nimport pandas as pd\n\ndf = pd.read_csv('output/embedded_1k_reviews.csv')\ndf['ada_embedding'] = df.ada_embedding.apply(eval).apply(np.array)Data visualization in 2DVisualizing_embeddings_in_2D.ipynbThe size of the embeddings varies with the complexity of the underlying model. In order to visualize this high dimensional data we use the t-SNE algorithm to transform the data into two dimensions.We color the individual reviews based on the star rating which the reviewer has given:1-star: red2-star: dark orange3-star: gold4-star: turquoise5-star: dark greenThe visualization seems to have produced roughly 3 clusters, one of which has mostly negative reviews.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nimport pandas as pd\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\nimport matplotlib\n\ndf = pd.read_csv('output/embedded_1k_reviews.csv')\nmatrix = df.ada_embedding.apply(eval).to_list()\n\n# Create a t-SNE model and transform the data\ntsne = TSNE(n_components=2, perplexity=15, random_state=42, init='random', learning_rate=200)\nvis_dims = tsne.fit_transform(matrix)\n\ncolors = [\"red\", \"darkorange\", \"gold\", \"turquiose\", \"darkgreen\"]\nx = [x for x,y in vis_dims]\ny = [y for x,y in vis_dims]\ncolor_indices = df.Score.values - 1\n\ncolormap = matplotlib.colors.ListedColormap(colors)\nplt.scatter(x, y, c=color_indices, cmap=colormap, alpha=0.3)\nplt.title(\"Amazon ratings visualized in language using t-SNE\")Collapse‍Embedding as a text feature encoder for ML algorithmsRegression_using_embeddings.ipynbAn embedding can be used as a general free-text feature encoder within a machine learning model. Incorporating embeddings will improve the performance of any machine learning model, if some of the relevant inputs are free text. An embedding can also be used as a categorical feature encoder within a ML model. This adds most value if the names of categorical variables are meaningful and numerous, such as job titles. Similarity embeddings generally perform better than search embeddings for this task.We observed that generally the embedding representation is very rich and information dense. For example, reducing the dimensionality of the inputs using SVD or PCA, even by 10%, generally results in worse downstream performance on specific tasks.This code splits the data into a training set and a testing set, which will be used by the following two use cases, namely regression and classification.1\n2\n3\n4\n5\n6\n7\n8\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(\n    list(df.ada_embedding.values),\n    df.Score,\n    test_size = 0.2,\n    random_state=42\n)Regression using the embedding featuresEmbeddings present an elegant way of predicting a numerical value. In this example we predict the reviewer’s star rating, based on the text of their review. Because the semantic information contained within embeddings is high, the prediction is decent even with very few reviews.We assume the score is a continuous variable between 1 and 5, and allow the algorithm to predict any floating point value. The ML algorithm minimizes the distance of the predicted value to the true score, and achieves a mean absolute error of 0.39, which means that on average the prediction is off by less than half a star.1\n2\n3\n4\n5\nfrom sklearn.ensemble import RandomForestRegressor\n\nrfr = RandomForestRegressor(n_estimators=100)\nrfr.fit(X_train, y_train)\npreds = rfr.predict(X_test)Collapse‍Classification using the embedding featuresClassification_using_embeddings.ipynbThis time, instead of having the algorithm predict a value anywhere between 1 and 5, we will attempt to classify the exact number of stars for a review into 5 buckets, ranging from 1 to 5 stars.After the training, the model learns to predict 1 and 5-star reviews much better than the more nuanced reviews (2-4 stars), likely due to more extreme sentiment expression.1\n2\n3\n4\n5\n6\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, accuracy_score\n\nclf = RandomForestClassifier(n_estimators=100)\nclf.fit(X_train, y_train)\npreds = clf.predict(X_test)Collapse‍Zero-shot classificationZero-shot_classification_with_embeddings.ipynbWe can use embeddings for zero shot classification without any labeled training data. For each class, we embed the class name or a short description of the class. To classify some new text in a zero-shot manner, we compare its embedding to all class embeddings and predict the class with the highest similarity.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nfrom openai.embeddings_utils import cosine_similarity, get_embedding\n\ndf= df[df.Score!=3]\ndf['sentiment'] = df.Score.replace({1:'negative', 2:'negative', 4:'positive', 5:'positive'})\n\nlabels = ['negative', 'positive']\nlabel_embeddings = [get_embedding(label, model=model) for label in labels]\n\ndef label_score(review_embedding, label_embeddings):\n   return cosine_similarity(review_embedding, label_embeddings[1]) - cosine_similarity(review_embedding, label_embeddings[0])\n\nprediction = 'positive' if label_score('Sample Review', label_embeddings) > 0 else 'negative'Collapse‍Obtaining user and product embeddings for cold-start recommendationUser_and_product_embeddings.ipynbWe can obtain a user embedding by averaging over all of their reviews. Similarly, we can obtain a product embedding by averaging over all the reviews about that product. In order to showcase the usefulness of this approach we use a subset of 50k reviews to cover more reviews per user and per product.We evaluate the usefulness of these embeddings on a separate test set, where we plot similarity of the user and product embedding as a function of the rating. Interestingly, based on this approach, even before the user receives the product we can predict better than random whether they would like the product.user_embeddings = df.groupby('UserId').ada_embedding.apply(np.mean)\nprod_embeddings = df.groupby('ProductId').ada_embedding.apply(np.mean)Collapse‍ClusteringClustering.ipynbClustering is one way of making sense of a large volume of textual data. Embeddings are useful for this task, as they provide semantically meaningful vector representations of each text. Thus, in an unsupervised way, clustering will uncover hidden groupings in our dataset.In this example, we discover four distinct clusters: one focusing on dog food, one on negative reviews, and two on positive reviews.1\n2\n3\n4\n5\n6\n7\n8\n9\nimport numpy as np\nfrom sklearn.cluster import KMeans\n\nmatrix = np.vstack(df.ada_embedding.values)\nn_clusters = 4\n\nkmeans = KMeans(n_clusters = n_clusters, init='k-means++', random_state=42)\nkmeans.fit(matrix)\ndf['Cluster'] = kmeans.labels_Collapse‍Text search using embeddingsSemantic_text_search_using_embeddings.ipynbTo retrieve the most relevant documents we use the cosine similarity between the embedding vectors of the query and each document, and return the highest scored documents.1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom openai.embeddings_utils import get_embedding, cosine_similarity\n\ndef search_reviews(df, product_description, n=3, pprint=True):\n   embedding = get_embedding(product_description, model='text-embedding-ada-002')\n   df['similarities'] = df.ada_embedding.apply(lambda x: cosine_similarity(x, embedding))\n   res = df.sort_values('similarities', ascending=False).head(n)\n   return res\n\nres = search_reviews(df, 'delicious beans', n=3)Collapse‍Code search using embeddingsCode_search.ipynbCode search works similarly to embedding-based text search. We provide a method to extract Python functions from all the Python files in a given repository. Each function is then indexed by the text-embedding-ada-002 model.To perform a code search, we embed the query in natural language using the same model. Then we calculate cosine similarity between the resulting query embedding and each of the function embeddings. The highest cosine similarity results are most relevant.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfrom openai.embeddings_utils import get_embedding, cosine_similarity\n\ndf['code_embedding'] = df['code'].apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\n\ndef search_functions(df, code_query, n=3, pprint=True, n_lines=7):\n   embedding = get_embedding(code_query, model='text-embedding-ada-002')\n   df['similarities'] = df.code_embedding.apply(lambda x: cosine_similarity(x, embedding))\n\n   res = df.sort_values('similarities', ascending=False).head(n)\n   return res\nres = search_functions(df, 'Completions API tests', n=3)Collapse‍Recommendations using embeddingsRecommendation_using_embeddings.ipynbBecause shorter distances between embedding vectors represent greater similarity, embeddings can be useful for recommendation.Below, we illustrate a basic recommender. It takes in a list of strings and one 'source' string, computes their embeddings, and then returns a ranking of the strings, ranked from most similar to least similar. As a concrete example, the linked notebook below applies a version of this function to the AG news dataset (sampled down to 2,000 news article descriptions) to return the top 5 most similar articles to any given source article.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ndef recommendations_from_strings(\n   strings: List[str],\n   index_of_source_string: int,\n   model=\"text-embedding-ada-002\",\n) -> List[int]:\n   \"\"\"Return nearest neighbors of a given string.\"\"\"\n\n   # get embeddings for all strings\n   embeddings = [embedding_from_string(string, model=model) for string in strings]\n\n   # get the embedding of the source string\n   query_embedding = embeddings[index_of_source_string]\n\n   # get distances between the source embedding and other embeddings (function from embeddings_utils.py)\n   distances = distances_from_embeddings(query_embedding, embeddings, distance_metric=\"cosine\")\n\n   # get indices of nearest neighbors (function from embeddings_utils.py)\n   indices_of_nearest_neighbors = indices_of_nearest_neighbors_from_distances(distances)\n   return indices_of_nearest_neighborsCollapse‍Limitations & risksOur embedding models may be unreliable or pose social risks in certain cases, and may cause harm in the absence of mitigations.Social biasLimitation: The models encode social biases, e.g. via stereotypes or negative sentiment towards certain groups.We found evidence of bias in our models via running the SEAT (May et al, 2019) and the Winogender (Rudinger et al, 2018) benchmarks. Together, these benchmarks consist of 7 tests that measure whether models contain implicit biases when applied to gendered names, regional names, and some stereotypes.For example, we found that our models more strongly associate (a) European American names with positive sentiment, when compared to African American names, and (b) negative stereotypes with black women.These benchmarks are limited in several ways: (a) they may not generalize to your particular use case, and (b) they only test for a very small slice of possible social bias.These tests are preliminary, and we recommend running tests for your specific use cases. These results should be taken as evidence of the existence of the phenomenon, not a definitive characterization of it for your use case. Please see our usage policies for more details and guidance.Please contact our support team via chat if you have any questions; we are happy to advise on this.Blindness to recent eventsLimitation: Models lack knowledge of events that occurred after August 2020.Our models are trained on datasets that contain some information about real world events up until 8/2020. If you rely on the models representing recent events, then they may not perform well.Frequently asked questionsHow can I tell how many tokens a string has before I embed it?In Python, you can split a string into tokens with OpenAI's tokenizer tiktoken.Example code:1\n2\n3\n4\n5\n6\n7\n8\n9\nimport tiktoken\n\ndef num_tokens_from_string(string: str, encoding_name: str) -> int:\n    \"\"\"Returns the number of tokens in a text string.\"\"\"\n    encoding = tiktoken.get_encoding(encoding_name)\n    num_tokens = len(encoding.encode(string))\n    return num_tokens\n\nnum_tokens_from_string(\"tiktoken is great!\", \"cl100k_base\")For second-generation embedding models like text-embedding-ada-002, use the cl100k_base encoding.More details and example code are in the OpenAI Cookbook guide how to count tokens with tiktoken.How can I retrieve K nearest embedding vectors quickly?For searching over many vectors quickly, we recommend using a vector database. You can find examples of working with vector databases and the OpenAI API in our Cookbook on GitHub.Vector database options include:Pinecone, a fully managed vector databaseWeaviate, an open-source vector search engineRedis as a vector databaseQdrant, a vector search engineMilvus, a vector database built for scalable similarity searchChroma, an open-source embeddings storeTypesense, fast open source vector searchZilliz, data infrastructure, powered by MilvusWhich distance function should I use?We recommend cosine similarity. The choice of distance function typically doesn’t matter much.OpenAI embeddings are normalized to length 1, which means that:Cosine similarity can be computed slightly faster using just a dot productCosine similarity and Euclidean distance will result in the identical rankingsCan I share my embeddings online?Customers own their input and output from our models, including in the case of embeddings. You are responsible for ensuring that the content you input to our API does not violate any applicable law or our Terms of Use.",
		"Fine-tuningLearn how to customize a model for your application.IntroductionFine-tuning lets you get more out of the models available through the API by providing:Higher quality results than prompt designAbility to train on more examples than can fit in a promptToken savings due to shorter promptsLower latency requestsGPT-3 has been pre-trained on a vast amount of text from the open internet. When given a prompt with just a few examples, it can often intuit what task you are trying to perform and generate a plausible completion. This is often called \"few-shot learning.\"Fine-tuning improves on few-shot learning by training on many more examples than can fit in the prompt, letting you achieve better results on a wide number of tasks. Once a model has been fine-tuned, you won't need to provide examples in the prompt anymore. This saves costs and enables lower-latency requests.At a high level, fine-tuning involves the following steps:Prepare and upload training dataTrain a new fine-tuned modelUse your fine-tuned modelVisit our pricing page to learn more about how fine-tuned model training and usage are billed.What models can be fine-tuned?Fine-tuning is currently only available for the following base models: davinci, curie, babbage, and ada. These are the original models that do not have any instruction following training (like text-davinci-003 does for example). You are also able to continue fine-tuning a fine-tuned model to add additional data without having to start from scratch.InstallationWe recommend using our OpenAI command-line interface (CLI). To install this, runpip install --upgrade openai(The following instructions work for version 0.9.4 and up. Additionally, the OpenAI CLI requires python 3.)Set your OPENAI_API_KEY environment variable by adding the following line into your shell initialization script (e.g. .bashrc, zshrc, etc.) or running it in the command line before the fine-tuning command:export OPENAI_API_KEY=\"<OPENAI_API_KEY>\"Prepare training dataTraining data is how you teach GPT-3 what you'd like it to say.Your data must be a JSONL document, where each line is a prompt-completion pair corresponding to a training example. You can use our CLI data preparation tool to easily convert your data into this file format.1\n2\n3\n4\n{\"prompt\": \"<prompt text>\", \"completion\": \"<ideal generated text>\"}\n{\"prompt\": \"<prompt text>\", \"completion\": \"<ideal generated text>\"}\n{\"prompt\": \"<prompt text>\", \"completion\": \"<ideal generated text>\"}\n...Designing your prompts and completions for fine-tuning is different from designing your prompts for use with our base models (Davinci, Curie, Babbage, Ada). In particular, while prompts for base models often consist of multiple examples (\"few-shot learning\"), for fine-tuning, each training example generally consists of a single input example and its associated output, without the need to give detailed instructions or include multiple examples in the same prompt.For more detailed guidance on how to prepare training data for various tasks, please refer to our preparing your dataset best practices.The more training examples you have, the better. We recommend having at least a couple hundred examples. In general, we've found that each doubling of the dataset size leads to a linear increase in model quality.CLI data preparation toolWe developed a tool which validates, gives suggestions and reformats your data:openai tools fine_tunes.prepare_data -f <LOCAL_FILE>This tool accepts different formats, with the only requirement that they contain a prompt and a completion column/key. You can pass a CSV, TSV, XLSX, JSON or JSONL file, and it will save the output into a JSONL file ready for fine-tuning, after guiding you through the process of suggested changes.Create a fine-tuned modelThe following assumes you've already prepared training data following the above instructions.Start your fine-tuning job using the OpenAI CLI:openai api fine_tunes.create -t <TRAIN_FILE_ID_OR_PATH> -m <BASE_MODEL>Where BASE_MODEL is the name of the base model you're starting from (ada, babbage, curie, or davinci). You can customize your fine-tuned model's name using the suffix parameter.Running the above command does several things:Uploads the file using the files API (or uses an already-uploaded file)Creates a fine-tune jobStreams events until the job is done (this often takes minutes, but can take hours if there are many jobs in the queue or your dataset is large)Every fine-tuning job starts from a base model, which defaults to curie. The choice of model influences both the performance of the model and the cost of running your fine-tuned model. Your model can be one of: ada, babbage, curie, or davinci. Visit our pricing page for details on fine-tune rates.After you've started a fine-tune job, it may take some time to complete. Your job may be queued behind other jobs on our system, and training our model can take minutes or hours depending on the model and dataset size. If the event stream is interrupted for any reason, you can resume it by running:openai api fine_tunes.follow -i <YOUR_FINE_TUNE_JOB_ID>When the job is done, it should display the name of the fine-tuned model.In addition to creating a fine-tune job, you can also list existing jobs, retrieve the status of a job, or cancel a job.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# List all created fine-tunes\nopenai api fine_tunes.list\n\n# Retrieve the state of a fine-tune. The resulting object includes\n# job status (which can be one of pending, running, succeeded, or failed)\n# and other information\nopenai api fine_tunes.get -i <YOUR_FINE_TUNE_JOB_ID>\n\n# Cancel a job\nopenai api fine_tunes.cancel -i <YOUR_FINE_TUNE_JOB_ID>Use a fine-tuned modelWhen a job has succeeded, the fine_tuned_model field will be populated with the name of the model. You may now specify this model as a parameter to our Completions API, and make requests to it using the Playground.After your job first completes, it may take several minutes for your model to become ready to handle requests. If completion requests to your model time out, it is likely because your model is still being loaded. If this happens, try again in a few minutes.You can start making requests by passing the model name as the model parameter of a completion request:OpenAI CLI:openai api completions.create -m <FINE_TUNED_MODEL> -p <YOUR_PROMPT>cURL:1\n2\n3\n4\ncurl https://api.openai.com/v1/completions \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": YOUR_PROMPT, \"model\": FINE_TUNED_MODEL}'Python:1\n2\n3\n4\nimport openai\nopenai.Completion.create(\n    model=FINE_TUNED_MODEL,\n    prompt=YOUR_PROMPT)Node.js:1\n2\n3\n4\nconst response = await openai.createCompletion({\n  model: FINE_TUNED_MODEL\n  prompt: YOUR_PROMPT,\n});You may continue to use all the other Completions parameters like temperature, frequency_penalty, presence_penalty, etc, on these requests to fine-tuned models.Delete a fine-tuned modelTo delete a fine-tuned model, you must be designated an \"owner\" within your organization.OpenAI CLI:openai api models.delete -i <FINE_TUNED_MODEL>cURL:curl -X \"DELETE\" https://api.openai.com/v1/models/<FINE_TUNED_MODEL> \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"Python:import openai\nopenai.Model.delete(FINE_TUNED_MODEL)Preparing your datasetFine-tuning is a powerful technique to create a new model that's specific to your use case. Before fine-tuning your model, we strongly recommend reading these best practices and specific guidelines for your use case below.Data formattingTo fine-tune a model, you'll need a set of training examples that each consist of a single input (\"prompt\") and its associated output (\"completion\"). This is notably different from using our base models, where you might input detailed instructions or multiple examples in a single prompt.Each prompt should end with a fixed separator to inform the model when the prompt ends and the completion begins. A simple separator which generally works well is \\n\\n###\\n\\n. The separator should not appear elsewhere in any prompt.Each completion should start with a whitespace due to our tokenization, which tokenizes most words with a preceding whitespace.Each completion should end with a fixed stop sequence to inform the model when the completion ends. A stop sequence could be \\n, ###, or any other token that does not appear in any completion.For inference, you should format your prompts in the same way as you did when creating the training dataset, including the same separator. Also specify the same stop sequence to properly truncate the completion.General best practicesFine-tuning performs better with more high-quality examples. To fine-tune a model that performs better than using a high-quality prompt with our base models, you should provide at least a few hundred high-quality examples, ideally vetted by human experts. From there, performance tends to linearly increase with every doubling of the number of examples. Increasing the number of examples is usually the best and most reliable way of improving performance.Classifiers are the easiest models to get started with. For classification problems we suggest using ada, which generally tends to perform only very slightly worse than more capable models once fine-tuned, whilst being significantly faster and cheaper.If you are fine-tuning on a pre-existing dataset rather than writing prompts from scratch, be sure to manually review your data for offensive or inaccurate content if possible, or review as many random samples of the dataset as possible if it is large.Specific guidelinesFine-tuning can solve a variety of problems, and the optimal way to use it may depend on your specific use case. Below, we've listed the most common use cases for fine-tuning and corresponding guidelines.ClassificationIs the model making untrue statements?Sentiment analysisCategorization for email triageConditional generationWrite an engaging ad based on a Wikipedia articleEntity extractionCustomer support chatbotProduct description based on a technical list of propertiesClassificationIn classification problems, each input in the prompt should be classified into one of the predefined classes. For this type of problem, we recommend:Use a separator at the end of the prompt, e.g. \\n\\n###\\n\\n. Remember to also append this separator when you eventually make requests to your model.Choose classes that map to a single token. At inference time, specify max_tokens=1 since you only need the first token for classification.Ensure that the prompt + completion doesn't exceed 2048 tokens, including the separatorAim for at least ~100 examples per classTo get class log probabilities you can specify logprobs=5 (for 5 classes) when using your modelEnsure that the dataset used for finetuning is very similar in structure and type of task as what the model will be used forCase study: Is the model making untrue statements?Let's say you'd like to ensure that the text of the ads on your website mention the correct product and company. In other words, you want to ensure the model isn't making things up. You may want to fine-tune a classifier which filters out incorrect ads.The dataset might look something like the following:{\"prompt\":\"Company: BHFF insurance\\nProduct: allround insurance\\nAd:One stop shop for all your insurance needs!\\nSupported:\", \"completion\":\" yes\"}\n{\"prompt\":\"Company: Loft conversion specialists\\nProduct: -\\nAd:Straight teeth in weeks!\\nSupported:\", \"completion\":\" no\"}In the example above, we used a structured input containing the name of the company, the product, and the associated ad. As a separator we used \\nSupported: which clearly separated the prompt from the completion. With a sufficient number of examples, the separator doesn't make much of a difference (usually less than 0.4%) as long as it doesn't appear within the prompt or the completion.For this use case we fine-tuned an ada model since it will be faster and cheaper, and the performance will be comparable to larger models because it is a classification task.Now we can query our model by making a Completion request.1\n2\n3\n4\n5\n6\n7\n8\ncurl https://api.openai.com/v1/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"prompt\": \"Company: Reliable accountants Ltd\\nProduct: Personal Tax help\\nAd:Best advice in town!\\nSupported:\",\n    \"max_tokens\": 1,\n    \"model\": \"YOUR_FINE_TUNED_MODEL_NAME\"\n  }'Which will return either  yes or  no.Case study: Sentiment analysisLet's say you'd like to get a degree to which a particular tweet is positive or negative. The dataset might look something like the following:{\"prompt\":\"Overjoyed with the new iPhone! ->\", \"completion\":\" positive\"}\n{\"prompt\":\"@lakers disappoint for a third straight night https://t.co/38EFe43 ->\", \"completion\":\" negative\"}Once the model is fine-tuned, you can get back the log probabilities for the first completion token by setting logprobs=2 on the completion request. The higher the probability for positive class, the higher the relative sentiment.Now we can query our model by making a Completion request.1\n2\n3\n4\n5\n6\n7\n8\ncurl https://api.openai.com/v1/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"prompt\": \"https://t.co/f93xEd2 Excited to share my latest blog post! ->\",\n    \"max_tokens\": 1,\n    \"model\": \"YOUR_FINE_TUNED_MODEL_NAME\"\n  }'Which will return:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n{\n  \"id\": \"cmpl-COMPLETION_ID\",\n  \"object\": \"text_completion\",\n  \"created\": 1589498378,\n  \"model\": \"YOUR_FINE_TUNED_MODEL_NAME\",\n  \"choices\": [\n    {\n      \"logprobs\": {\n        \"text_offset\": [\n          19\n        ],\n        \"token_logprobs\": [\n          -0.03597255\n        ],\n        \"tokens\": [\n          \" positive\"\n        ],\n        \"top_logprobs\": [\n          {\n            \" negative\": -4.9785037,\n            \" positive\": -0.03597255\n          }\n        ]\n      },\n\n      \"text\": \" positive\",\n      \"index\": 0,\n      \"finish_reason\": \"length\"\n    }\n  ]\n}Case study: Categorization for Email triageLet's say you'd like to categorize incoming email into one of a large number of predefined categories. For classification into a large number of categories, we recommend you convert those categories into numbers, which will work well up to ~500 categories. We've observed that adding a space before the number sometimes slightly helps the performance, due to tokenization. You may want to structure your training data as follows:{\"prompt\":\"Subject: <email_subject>\\nFrom:<customer_name>\\nDate:<date>\\nContent:<email_body>\\n\\n###\\n\\n\", \"completion\":\" <numerical_category>\"}For example:{\"prompt\":\"Subject: Update my address\\nFrom:Joe Doe\\nTo:support@ourcompany.com\\nDate:2021-06-03\\nContent:Hi,\\nI would like to update my billing address to match my delivery address.\\n\\nPlease let me know once done.\\n\\nThanks,\\nJoe\\n\\n###\\n\\n\", \"completion\":\" 4\"}In the example above we used an incoming email capped at 2043 tokens as input. (This allows for a 4 token separator and a one token completion, summing up to 2048.) As a separator we used \\n\\n###\\n\\n and we removed any occurrence of ### within the email.Conditional generationConditional generation is a problem where the content needs to be generated given some kind of input. This includes paraphrasing, summarizing, entity extraction, product description writing given specifications, chatbots and many others. For this type of problem we recommend:Use a separator at the end of the prompt, e.g. \\n\\n###\\n\\n. Remember to also append this separator when you eventually make requests to your model.Use an ending token at the end of the completion, e.g.  ENDRemember to add the ending token as a stop sequence during inference, e.g. stop=[\" END\"]Aim for at least ~500 examplesEnsure that the prompt + completion doesn't exceed 2048 tokens, including the separatorEnsure the examples are of high quality and follow the same desired formatEnsure that the dataset used for finetuning is very similar in structure and type of task as what the model will be used forUsing Lower learning rate and only 1-2 epochs tends to work better for these use casesCase study: Write an engaging ad based on a Wikipedia articleThis is a generative use case so you would want to ensure that the samples you provide are of the highest quality, as the fine-tuned model will try to imitate the style (and mistakes) of the given examples. A good starting point is around 500 examples. A sample dataset might look like this:{\"prompt\":\"<Product Name>\\n<Wikipedia description>\\n\\n###\\n\\n\", \"completion\":\" <engaging ad> END\"}For example:{\"prompt\":\"Samsung Galaxy Feel\\nThe Samsung Galaxy Feel is an Android smartphone developed by Samsung Electronics exclusively for the Japanese market. The phone was released in June 2017 and was sold by NTT Docomo. It runs on Android 7.0 (Nougat), has a 4.7 inch display, and a 3000 mAh battery.\\nSoftware\\nSamsung Galaxy Feel runs on Android 7.0 (Nougat), but can be later updated to Android 8.0 (Oreo).\\nHardware\\nSamsung Galaxy Feel has a 4.7 inch Super AMOLED HD display, 16 MP back facing and 5 MP front facing cameras. It has a 3000 mAh battery, a 1.6 GHz Octa-Core ARM Cortex-A53 CPU, and an ARM Mali-T830 MP1 700 MHz GPU. It comes with 32GB of internal storage, expandable to 256GB via microSD. Aside from its software and hardware specifications, Samsung also introduced a unique a hole in the phone's shell to accommodate the Japanese perceived penchant for personalizing their mobile phones. The Galaxy Feel's battery was also touted as a major selling point since the market favors handsets with longer battery life. The device is also waterproof and supports 1seg digital broadcasts using an antenna that is sold separately.\\n\\n###\\n\\n\", \"completion\":\"Looking for a smartphone that can do it all? Look no further than Samsung Galaxy Feel! With a slim and sleek design, our latest smartphone features high-quality picture and video capabilities, as well as an award winning battery life. END\"}Here we used a multi line separator, as Wikipedia articles contain multiple paragraphs and headings. We also used a simple end token, to ensure that the model knows when the completion should finish.Case study: Entity extractionThis is similar to a language transformation task. To improve the performance, it is best to either sort different extracted entities alphabetically or in the same order as they appear in the original text. This will help the model to keep track of all the entities which need to be generated in order. The dataset could look as follows:{\"prompt\":\"<any text, for example news article>\\n\\n###\\n\\n\", \"completion\":\" <list of entities, separated by a newline> END\"}For example:{\"prompt\":\"Portugal will be removed from the UK's green travel list from Tuesday, amid rising coronavirus cases and concern over a \\\"Nepal mutation of the so-called Indian variant\\\". It will join the amber list, meaning holidaymakers should not visit and returnees must isolate for 10 days...\\n\\n###\\n\\n\", \"completion\":\" Portugal\\nUK\\nNepal mutation\\nIndian variant END\"}A multi-line separator works best, as the text will likely contain multiple lines. Ideally there will be a high diversity of the types of input prompts (news articles, Wikipedia pages, tweets, legal documents), which reflect the likely texts which will be encountered when extracting entities.Case study: Customer support chatbotA chatbot will normally contain relevant context about the conversation (order details), summary of the conversation so far as well as most recent messages. For this use case the same past conversation can generate multiple rows in the dataset, each time with a slightly different context, for every agent generation as a completion. This use case will require a few thousand examples, as it will likely deal with different types of requests, and customer issues. To ensure the performance is of high quality we recommend vetting the conversation samples to ensure the quality of agent messages. The summary can be generated with a separate text transformation fine tuned model. The dataset could look as follows:{\"prompt\":\"Summary: <summary of the interaction so far>\\n\\nSpecific information:<for example order details in natural language>\\n\\n###\\n\\nCustomer: <message1>\\nAgent: <response1>\\nCustomer: <message2>\\nAgent:\", \"completion\":\" <response2>\\n\"}\n{\"prompt\":\"Summary: <summary of the interaction so far>\\n\\nSpecific information:<for example order details in natural language>\\n\\n###\\n\\nCustomer: <message1>\\nAgent: <response1>\\nCustomer: <message2>\\nAgent: <response2>\\nCustomer: <message3>\\nAgent:\", \"completion\":\" <response3>\\n\"}Here we purposefully separated different types of input information, but maintained Customer Agent dialog in the same format between a prompt and a completion. All the completions should only be by the agent, and we can use \\n as a stop sequence when doing inference.Case study: Product description based on a technical list of propertiesHere it is important to convert the input data into a natural language, which will likely lead to superior performance. For example, the following format:{\"prompt\":\"Item=handbag, Color=army_green, price=$99, size=S->\", \"completion\":\" This stylish small green handbag will add a unique touch to your look, without costing you a fortune.\"}Won't work as well as:{\"prompt\":\"Item is a handbag. Colour is army green. Price is midrange. Size is small.->\", \"completion\":\" This stylish small green handbag will add a unique touch to your look, without costing you a fortune.\"}For high performance ensure that the completions were based on the description provided. If external content is often consulted, then adding such content in an automated way would improve the performance. If the description is based on images, it may help to use an algorithm to extract a textual description of the image. Since completions are only one sentence long, we can use . as the stop sequence during inference.Advanced usageCustomize your model nameYou can add a suffix of up to 40 characters to your fine-tuned model name using the suffix parameter.OpenAI CLI:openai api fine_tunes.create -t test.jsonl -m ada --suffix \"custom model name\"The resulting name would be:ada:ft-your-org:custom-model-name-2022-02-15-04-21-04Analyzing your fine-tuned modelWe attach a result file to each job once it has been completed. This results file ID will be listed when you retrieve a fine-tune, and also when you look at the events on a fine-tune. You can download these files:OpenAI CLI:openai api fine_tunes.results -i <YOUR_FINE_TUNE_JOB_ID>CURL:curl https://api.openai.com/v1/files/$RESULTS_FILE_ID/content \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" > results.csvThe _results.csv file contains a row for each training step, where a step refers to one forward and backward pass on a batch of data. In addition to the step number, each row contains the following fields corresponding to that step:elapsed_tokens: the number of tokens the model has seen so far (including repeats)elapsed_examples: the number of examples the model has seen so far (including repeats), where one example is one element in your batch. For example, if batch_size = 4, each step will increase elapsed_examples by 4.training_loss: loss on the training batchtraining_sequence_accuracy: the percentage of completions in the training batch for which the model's predicted tokens matched the true completion tokens exactly. For example, with a batch_size of 3, if your data contains the completions [[1, 2], [0, 5], [4, 2]] and the model predicted [[1, 1], [0, 5], [4, 2]], this accuracy will be 2/3 = 0.67training_token_accuracy: the percentage of tokens in the training batch that were correctly predicted by the model. For example, with a batch_size of 3, if your data contains the completions [[1, 2], [0, 5], [4, 2]] and the model predicted [[1, 1], [0, 5], [4, 2]], this accuracy will be 5/6 = 0.83Classification specific metricsWe also provide the option of generating additional classification-specific metrics in the results file, such as accuracy and weighted F1 score. These metrics are periodically calculated against the full validation set and at the end of fine-tuning. You will see them as additional columns in your results file.To enable this, set the parameter --compute_classification_metrics. Additionally, you must provide a validation file, and set either the classification_n_classes parameter, for multiclass classification, or classification_positive_class, for binary classification.OpenAI CLI:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# For multiclass classification\nopenai api fine_tunes.create \\\n  -t <TRAIN_FILE_ID_OR_PATH> \\\n  -v <VALIDATION_FILE_OR_PATH> \\\n  -m <MODEL> \\\n  --compute_classification_metrics \\\n  --classification_n_classes <N_CLASSES>\n\n# For binary classification\nopenai api fine_tunes.create \\\n  -t <TRAIN_FILE_ID_OR_PATH> \\\n  -v <VALIDATION_FILE_OR_PATH> \\\n  -m <MODEL> \\\n  --compute_classification_metrics \\\n  --classification_n_classes 2 \\\n  --classification_positive_class <POSITIVE_CLASS_FROM_DATASET>The following metrics will be displayed in your results file if you set --compute_classification_metrics:For multiclass classificationclassification/accuracy: accuracyclassification/weighted_f1_score: weighted F-1 scoreFor binary classificationThe following metrics are based on a classification threshold of 0.5 (i.e. when the probability is > 0.5, an example is classified as belonging to the positive class.)classification/accuracyclassification/precisionclassification/recallclassification/f{beta}classification/auroc - AUROCclassification/auprc - AUPRCNote that these evaluations assume that you are using text labels for classes that tokenize down to a single token, as described above. If these conditions do not hold, the numbers you get will likely be wrong.ValidationYou can reserve some of your data for validation. A validation file has exactly the same format as a train file, and your train and validation data should be mutually exclusive.If you include a validation file when creating your fine-tune job, the generated results file will include evaluations on how well the fine-tuned model performs against your validation data at periodic intervals during training.OpenAI CLI:1\n2\n3\nopenai api fine_tunes.create -t <TRAIN_FILE_ID_OR_PATH> \\\n  -v <VALIDATION_FILE_ID_OR_PATH> \\\n  -m <MODEL>If you provided a validation file, we periodically calculate metrics on batches of validation data during training time. You will see the following additional metrics in your results file:validation_loss: loss on the validation batchvalidation_sequence_accuracy: the percentage of completions in the validation batch for which the model's predicted tokens matched the true completion tokens exactly. For example, with a batch_size of 3, if your data contains the completion [[1, 2], [0, 5], [4, 2]] and the model predicted [[1, 1], [0, 5], [4, 2]], this accuracy will be 2/3 = 0.67validation_token_accuracy: the percentage of tokens in the validation batch that were correctly predicted by the model. For example, with a batch_size of 3, if your data contains the completion [[1, 2], [0, 5], [4, 2]] and the model predicted [[1, 1], [0, 5], [4, 2]], this accuracy will be 5/6 = 0.83HyperparametersWe've picked default hyperparameters that work well across a range of use cases. The only required parameter is the training file.That said, tweaking the hyperparameters used for fine-tuning can often lead to a model that produces higher quality output. In particular, you may want to configure the following:model: The name of the base model to fine-tune. You can select one of \"ada\", \"babbage\", \"curie\", or \"davinci\". To learn more about these models, see the Models documentation.n_epochs - defaults to 4. The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.batch_size - defaults to ~0.2% of the number of examples in the training set, capped at 256. The batch size is the number of training examples used to train a single forward and backward pass. In general, we've found that larger batch sizes tend to work better for larger datasets.learning_rate_multiplier - defaults to 0.05, 0.1, or 0.2 depending on final batch_size. The fine-tuning learning rate is the original learning rate used for pretraining multiplied by this multiplier. We recommend experimenting with values in the range 0.02 to 0.2 to see what produces the best results. Empirically, we've found that larger learning rates often perform better with larger batch sizes.compute_classification_metrics - defaults to False. If True, for fine-tuning for classification tasks, computes classification-specific metrics (accuracy, F-1 score, etc) on the validation set at the end of every epoch.To configure these additional hyperparameters, pass them in via command line flags on the OpenAI CLI, for example:1\n2\n3\n4\nopenai api fine_tunes.create \\\n  -t file-JD89ePi5KMsB3Tayeli5ovfW \\\n  -m ada \\\n  --n_epochs 1Continue fine-tuning from a fine-tuned modelIf you have already fine-tuned a model for your task and now have additional training data that you would like to incorporate, you can continue fine-tuning from the model. This creates a model that has learned from all of the training data without having to re-train from scratch.To do this, pass in the fine-tuned model name when creating a new fine-tuning job (e.g. -m curie:ft-<org>-<date>). Other training parameters do not have to be changed, however if your new training data is much smaller than your previous training data, you may find it useful to reduce learning_rate_multiplier by a factor of 2 to 4.Weights & BiasesYou can sync your fine-tunes with Weights & Biases to track experiments, models, and datasets.To get started, you will need a Weights & Biases account and a paid OpenAI plan. To make sure you are using the lastest version of openai and wandb, run:pip install --upgrade openai wandbTo sync your fine-tunes with Weights & Biases, run:openai wandb syncYou can read the Weights & Biases documentation for more information on this integration.Example notebooksClassificationfinetuning-classification.ipynbThis notebook will demonstrate how to fine-tune a model that can classify whether a piece of input text is related to Baseball or Hockey. We will perform this task in four steps in the notebook:Data exploration will give an overview of the data source and what an example looks likeData preparation will turn our data source into a jsonl file that can be used for fine-tuningFine-tuning will kick off the fine-tuning job and explain the resulting model's performanceUsing the model will demonstrate making requests to the fine-tuned model to get predictions.Collapse‍Question answeringolympics-1-collect-data.ipynbolympics-2-create-qa.ipynbolympics-3-train-qa.ipynbThe idea of this project is to create a question answering model, based on a few paragraphs of provided text. Base GPT-3 models do a good job at answering questions when the answer is contained within the paragraph, however if the answer isn't contained, the base models tend to try their best to answer anyway, often leading to confabulated answers.To create a model which answers questions only if there is sufficient context for doing so, we first create a dataset of questions and answers based on paragraphs of text. In order to train the model to answer only when the answer is present, we also add adversarial examples, where the question doesn't match the context. In those cases, we ask the model to output \"No sufficient context for answering the question\".We will perform this task in three notebooks:The first notebook focuses on collecting recent data, which GPT-3 didn't see during it's pre-training. We picked the topic of Olympic Games 2020 (which actually took place in the summer of 2021), and downloaded 713 unique pages. We organized the dataset by individual sections, which will serve as context for asking and answering the questions.The second notebook will utilize Davinci-instruct to ask a few questions based on a Wikipedia section, as well as answer those questions, based on that section.The third notebook will utilize the dataset of context, question and answer pairs to additionally create adversarial questions and context pairs, where the question was not generated on that context. In those cases the model will be prompted to answer \"No sufficient context for answering the question\". We will also train a discriminator model, which predicts whether the question can be answered based on the context or not.Collapse‍",
		"Image generation BetaLearn how to generate or manipulate images with our DALL·E modelsIntroductionThe Images API provides three methods for interacting with images:Creating images from scratch based on a text promptCreating edits of an existing image based on a new text promptCreating variations of an existing imageThis guide covers the basics of using these three API endpoints with useful code samples. To see them in action, check out our DALL·E preview app.The Images API is in beta. During this time the API and models will evolve based on your feedback. To ensure all users can prototype comfortably, the default rate limit is 50 images per minute. You can learn more about rate limits in our rate limit guide.UsageGenerationsThe image generations endpoint allows you to create an original image given a text prompt. Generated images can have a size of 256x256, 512x512, or 1024x1024 pixels. Smaller sizes are faster to generate. You can request 1-10 images at a time using the n parameter.Generate an imagepythonSelect librarypythonnode.jscurlCopy‍1\n2\n3\n4\n5\n6\nresponse = openai.Image.create(\n  prompt=\"a white siamese cat\",\n  n=1,\n  size=\"1024x1024\"\n)\nimage_url = response['data'][0]['url']The more detailed the description, the more likely you are to get the result that you or your end user want. You can explore the examples in the DALL·E preview app for more prompting inspiration. Here's a quick example:PromptGenerationa white siamese cata close up, studio photographic portrait of a white siamese cat that looks curious, backlit earsEach image can be returned as either a URL or Base64 data, using the response_format parameter. URLs will expire after an hour.EditsThe image edits endpoint allows you to edit and extend an image by uploading a mask. The transparent areas of the mask indicate where the image should be edited, and the prompt should describe the full new image, not just the erased area. This endpoint can enable experiences like the editor in our DALL·E preview app.Edit an imagepythonSelect librarypythonnode.jscurlCopy‍1\n2\n3\n4\n5\n6\n7\n8\nresponse = openai.Image.create_edit(\n  image=open(\"sunlit_lounge.png\", \"rb\"),\n  mask=open(\"mask.png\", \"rb\"),\n  prompt=\"A sunlit indoor lounge area with a pool containing a flamingo\",\n  n=1,\n  size=\"1024x1024\"\n)\nimage_url = response['data'][0]['url']ImageMaskOutputPrompt: a sunlit indoor lounge area with a pool containing a flamingoThe uploaded image and mask must both be square PNG images less than 4MB in size, and also must have the same dimensions as each other. The non-transparent areas of the mask are not used when generating the output, so they don’t necessarily need to match the original image like the example above.VariationsThe image variations endpoint allows you to generate a variation of a given image.Generate an image variationpythonSelect librarypythonnode.jscurlCopy‍1\n2\n3\n4\n5\n6\nresponse = openai.Image.create_variation(\n  image=open(\"corgi_and_cat_paw.png\", \"rb\"),\n  n=1,\n  size=\"1024x1024\"\n)\nimage_url = response['data'][0]['url']ImageOutputSimilar to the edits endpoint, the input image must be a square PNG image less than 4MB in size.Content moderationPrompts and images are filtered based on our content policy, returning an error when a prompt or image is flagged. If you have any feedback on false positives or related issues, please contact us through our help center.Language-specific tipsNode.jsPythonUsing in-memory image dataThe Node.js examples in the guide above use the fs module to read image data from disk. In some cases, you may have your image data in memory instead. Here's an example API call that uses image data stored in a Node.js Buffer object:1\n2\n3\n4\n5\n6\n7\n8\n9\n// This is the Buffer object that contains your image data\nconst buffer = [your image data];\n// Set a `name` that ends with .png so that the API knows it's a PNG image\nbuffer.name = \"image.png\";\nconst response = await openai.createImageVariation(\n  buffer,\n  1,\n  \"1024x1024\"\n);Working with TypeScriptIf you're using TypeScript, you may encounter some quirks with image file arguments. Here's an example of working around the type mismatch by explicitly casting the argument:1\n2\n3\n4\n5\n6\n// Cast the ReadStream to `any` to appease the TypeScript compiler\nconst response = await openai.createImageVariation(\n  fs.createReadStream(\"image.png\") as any,\n  1,\n  \"1024x1024\"\n);And here's a similar example for in-memory image data:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n// This is the Buffer object that contains your image data\nconst buffer: Buffer = [your image data];\n// Cast the buffer to `any` so that we can set the `name` property\nconst file: any = buffer;\n// Set a `name` that ends with .png so that the API knows it's a PNG image\nfile.name = \"image.png\";\nconst response = await openai.createImageVariation(\n  file,\n  1,\n  \"1024x1024\"\n);Error handlingAPI requests can potentially return errors due to invalid inputs, rate limits, or other issues. These errors can be handled with a try...catch statement, and the error details can be found in either error.response or error.message:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\ntry {\n  const response = await openai.createImageVariation(\n    fs.createReadStream(\"image.png\"),\n    1,\n    \"1024x1024\"\n  );\n  console.log(response.data.data[0].url);\n} catch (error) {\n  if (error.response) {\n    console.log(error.response.status);\n    console.log(error.response.data);\n  } else {\n    console.log(error.message);\n  }\n}",
		"Chat completions BetaUsing the OpenAI Chat API, you can build your own applications with gpt-3.5-turbo and gpt-4 to do things like:Draft an email or other piece of writingWrite Python codeAnswer questions about a set of documentsCreate conversational agentsGive your software a natural language interfaceTutor in a range of subjectsTranslate languagesSimulate characters for video games\nand much moreThis guide explains how to make an API call for chat-based language models and shares tips for getting good results. You can also experiment with the new chat format in the OpenAI Playground.IntroductionChat models take a series of messages as input, and return a model-generated message as output.Although the chat format is designed to make multi-turn conversations easy, it’s just as useful for single-turn tasks without any conversations (such as those previously served by instruction following models like text-davinci-003).An example API call looks as follows:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# Note: you need to be using OpenAI Python v0.27.0 for the code below to work\nimport openai\n\nopenai.ChatCompletion.create(\n  model=\"gpt-3.5-turbo\",\n  messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n        {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n        {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n        {\"role\": \"user\", \"content\": \"Where was it played?\"}\n    ]\n)The main input is the messages parameter. Messages must be an array of message objects, where each object has a role (either \"system\", \"user\", or \"assistant\") and content (the content of the message). Conversations can be as short as 1 message or fill many pages.Typically, a conversation is formatted with a system message first, followed by alternating user and assistant messages.The system message helps set the behavior of the assistant. In the example above, the assistant was instructed with \"You are a helpful assistant.\"gpt-3.5-turbo-0301 does not always pay strong attention to system messages. Future models will be trained to pay stronger attention to system messages.The user messages help instruct the assistant. They can be generated by the end users of an application, or set by a developer as an instruction.The assistant messages help store prior responses. They can also be written by a developer to help give examples of desired behavior.Including the conversation history helps when user instructions refer to prior messages. In the example above, the user’s final question of \"Where was it played?\" only makes sense in the context of the prior messages about the World Series of 2020. Because the models have no memory of past requests, all relevant information must be supplied via the conversation. If a conversation cannot fit within the model’s token limit, it will need to be shortened in some way.Response formatAn example API response looks as follows:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n{\n 'id': 'chatcmpl-6p9XYPYSTTRi0xEviKjjilqrWU2Ve',\n 'object': 'chat.completion',\n 'created': 1677649420,\n 'model': 'gpt-3.5-turbo',\n 'usage': {'prompt_tokens': 56, 'completion_tokens': 31, 'total_tokens': 87},\n 'choices': [\n   {\n    'message': {\n      'role': 'assistant',\n      'content': 'The 2020 World Series was played in Arlington, Texas at the Globe Life Field, which was the new home stadium for the Texas Rangers.'},\n    'finish_reason': 'stop',\n    'index': 0\n   }\n  ]\n}In Python, the assistant’s reply can be extracted with response['choices'][0]['message']['content'].Every response will include a finish_reason. The possible values for finish_reason are:stop: API returned complete model outputlength: Incomplete model output due to max_tokens parameter or token limitcontent_filter: Omitted content due to a flag from our content filtersnull: API response still in progress or incompleteManaging tokensLanguage models read text in chunks called tokens. In English, a token can be as short as one character or as long as one word (e.g., a or  apple), and in some languages tokens can be even shorter than one character or even longer than one word.For example, the string \"ChatGPT is great!\" is encoded into six tokens: [\"Chat\", \"G\", \"PT\", \" is\", \" great\", \"!\"].The total number of tokens in an API call affects:How much your API call costs, as you pay per tokenHow long your API call takes, as writing more tokens takes more timeWhether your API call works at all, as total tokens must be below the model’s maximum limit (4096 tokens for gpt-3.5-turbo-0301)Both input and output tokens count toward these quantities. For example, if your API call used 10 tokens in the message input and you received 20 tokens in the message output, you would be billed for 30 tokens.To see how many tokens are used by an API call, check the usage field in the API response (e.g., response['usage']['total_tokens']).Chat models like gpt-3.5-turbo and gpt-4 use tokens in the same way as other models, but because of their message-based formatting, it's more difficult to count how many tokens will be used by a conversation.Deep diveCounting tokens for chat API callsTo see how many tokens are in a text string without making an API call, use OpenAI’s tiktoken Python library. Example code can be found in the OpenAI Cookbook’s guide on how to count tokens with tiktoken.Each message passed to the API consumes the number of tokens in the content, role, and other fields, plus a few extra for behind-the-scenes formatting. This may change slightly in the future.If a conversation has too many tokens to fit within a model’s maximum limit (e.g., more than 4096 tokens for gpt-3.5-turbo), you will have to truncate, omit, or otherwise shrink your text until it fits. Beware that if a message is removed from the messages input, the model will lose all knowledge of it.Note too that very long conversations are more likely to receive incomplete replies. For example, a gpt-3.5-turbo conversation that is 4090 tokens long will have its reply cut off after just 6 tokens.Instructing chat modelsBest practices for instructing models may change from model version to version. The advice that follows applies to gpt-3.5-turbo-0301 and may not apply to future models.Many conversations begin with a system message to gently instruct the assistant. For example, here is one of the system messages used for ChatGPT:You are ChatGPT, a large language model trained by OpenAI. Answer as concisely as possible. Knowledge cutoff: {knowledge_cutoff} Current date: {current_date}In general, gpt-3.5-turbo-0301 does not pay strong attention to the system message, and therefore important instructions are often better placed in a user message.If the model isn’t generating the output you want, feel free to iterate and experiment with potential improvements. You can try approaches like:Make your instruction more explicitSpecify the format you want the answer inAsk the model to think step by step or debate pros and cons before settling on an answerFor more prompt engineering ideas, read the OpenAI Cookbook guide on techniques to improve reliability.Beyond the system message, the temperature and max tokens are two of many options developers have to influence the output of the chat models. For temperature, higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. In the case of max tokens, if you want to limit a response to a certain length, max tokens can be set to an arbitrary number. This may cause issues for example if you set the max tokens value to 5 since the output will be cut-off and the result will not make sense to users.Chat vs CompletionsBecause gpt-3.5-turbo performs at a similar capability to text-davinci-003 but at 10% the price per token, we recommend gpt-3.5-turbo for most use cases.For many developers, the transition is as simple as rewriting and retesting a prompt.For example, if you translated English to French with the following completions prompt:Translate the following English text to French: \"{text}\"An equivalent chat conversation could look like:1\n2\n3\n4\n[\n  {\"role\": \"system\", \"content\": \"You are a helpful assistant that translates English to French.\"},\n  {\"role\": \"user\", \"content\": 'Translate the following English text to French: \"{text}\"'}\n]Or even just the user message:1\n2\n3\n[\n  {\"role\": \"user\", \"content\": 'Translate the following English text to French: \"{text}\"'}\n]FAQIs fine-tuning available for gpt-3.5-turbo?No. As of Mar 1, 2023, you can only fine-tune base GPT-3 models. See the fine-tuning guide for more details on how to use fine-tuned models.Do you store the data that is passed into the API?As of March 1st, 2023, we retain your API data for 30 days but no longer use your data sent via the API to improve our models. Learn more in our data usage policy.Adding a moderation layerIf you want to add a moderation layer to the outputs of the Chat API, you can follow our moderation guide to prevent content that violates OpenAI’s usage policies from being shown.",
		"TutorialsGet started with the OpenAI API by building real AI apps step by step. Website Q&A with EmbeddingsLearn how to build an AI that can answer questions about your website.Coming soonLearn how to build and deploy an AI that can answer questions about local files.Coming soonLearn how to build and deploy an AI chat bot that understands multiple knowledge bases.Looking for more ideas? Check out our Examples gallery or the OpenAI Cookbook on GitHub.",
		"ModelsOverviewThe OpenAI API is powered by a diverse set of models with different capabilities and price points. You can also make limited customizations to our original base models for your specific use case with fine-tuning.ModelsDescriptionGPT-4 Limited betaA set of models that improve on GPT-3.5 and can understand as well as generate natural language or codeGPT-3.5A set of models that improve on GPT-3 and can understand as well as generate natural language or codeDALL·EBetaA model that can generate and edit images given a natural language promptWhisperBetaA model that can convert audio into textEmbeddingsA set of models that can convert text into a numerical formModerationA fine-tuned model that can detect whether text may be sensitive or unsafeGPT-3A set of models that can understand and generate natural languageCodexDeprecatedA set of models that can understand and generate code, including translating natural language to codeWe have also published open source models including Point-E, Whisper, Jukebox, and CLIP.Visit our model index for researchers to learn\nmore about which models have been featured in our research papers and the differences\nbetween model series like InstructGPT and GPT-3.5.Model endpoint compatibilityEndpointModel name/v1/chat/completionsgpt-4, gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, gpt-3.5-turbo, gpt-3.5-turbo-0301/v1/completionstext-davinci-003, text-davinci-002, text-curie-001, text-babbage-001, text-ada-001/v1/editstext-davinci-edit-001, code-davinci-edit-001/v1/audio/transcriptionswhisper-1/v1/audio/translationswhisper-1/v1/fine-tunesdavinci, curie, babbage, ada/v1/embeddingstext-embedding-ada-002, text-search-ada-doc-001/v1/moderationstext-moderation-stable, text-moderation-latestThis list does not include our first-generation embedding models nor our DALL·E models.Continuous model upgradesWith the release of gpt-3.5-turbo, some of our models are now being continually updated. We also offer static model versions that developers can continue using for at least three months after an updated model has been introduced. With the new cadence of model updates, we are also giving people the ability to contribute evals to help us improve the model for different use cases. If you are interested, check out the OpenAI Evals repository.The following models are the temporary snapshots, we will announce their deprecation dates once updated versions are available. If you want to use the latest model version, use the standard model names like gpt-4 or gpt-3.5-turbo.Model nameDeprecation dategpt-3.5-turbo-0301TBDgpt-4-0314TBDgpt-4-32k-0314TBDGPT-4 Limited betaGPT-4 is a large multimodal model (accepting text inputs and emitting text outputs today, with image inputs coming in the future) that can solve difficult problems with greater accuracy than any of our previous models, thanks to its broader general knowledge and advanced reasoning capabilities. Like gpt-3.5-turbo, GPT-4 is optimized for chat but works well for traditional completions tasks both using the Chat Completions API. Learn how to use GPT-4 in our chat guide.GPT-4 is currently in a limited beta and only accessible to those who have been granted access. Please join the waitlist to get access when capacity is available.Latest modelDescriptionMax tokensTraining datagpt-4More capable than any GPT-3.5 model, able to do more complex tasks, and optimized for chat. Will be updated with our latest model iteration.8,192 tokensUp to Sep 2021gpt-4-0314Snapshot of gpt-4 from March 14th 2023. Unlike gpt-4, this model will not receive updates, and will be deprecated 3 months after a new version is released.8,192 tokensUp to Sep 2021gpt-4-32kSame capabilities as the base gpt-4 mode but with 4x the context length. Will be updated with our latest model iteration.32,768 tokensUp to Sep 2021gpt-4-32k-0314Snapshot of gpt-4-32 from March 14th 2023. Unlike gpt-4-32k, this model will not receive updates, and will be deprecated 3 months after a new version is released.32,768 tokensUp to Sep 2021For many basic tasks, the difference between GPT-4 and GPT-3.5 models is not significant. However, in more complex reasoning situations, GPT-4 is much more capable than any of our previous models.GPT-3.5GPT-3.5 models can understand and generate natural language or code. Our most capable and cost effective model in the GPT-3.5 family is gpt-3.5-turbo which has been optimized for chat but works well for traditional completions tasks as well.Latest modelDescriptionMax tokensTraining datagpt-3.5-turboMost capable GPT-3.5 model and optimized for chat at 1/10th the cost of text-davinci-003. Will be updated with our latest model iteration.4,096 tokensUp to Sep 2021gpt-3.5-turbo-0301Snapshot of gpt-3.5-turbo from March 1st 2023. Unlike gpt-3.5-turbo, this model will not receive updates, and will be deprecated 3 months after a new version is released.4,096 tokensUp to Sep 2021text-davinci-003Can do any language task with better quality, longer output, and consistent instruction-following than the curie, babbage, or ada models. Also supports inserting completions within text.4,097 tokensUp to Jun 2021text-davinci-002Similar capabilities to text-davinci-003 but trained with supervised fine-tuning instead of reinforcement learning4,097 tokensUp to Jun 2021code-davinci-002Optimized for code-completion tasks8,001 tokensUp to Jun 2021We recommend using gpt-3.5-turbo over the other GPT-3.5 models because of its lower cost.OpenAI models are non-deterministic, meaning that identical inputs can yield different outputs. Setting temperature to 0 will make the outputs mostly deterministic, but a small amount of variability may remain.Feature-specific modelsWhile the new gpt-3.5-turbo model is optimized for chat, it works very well for traditional completion tasks. The original GPT-3.5 models are optimized for text completion.Our endpoints for creating embeddings and editing text use their own sets of specialized models.Finding the right modelExperimenting with gpt-3.5-turbo is a great way to find out what the API is capable of doing. After you have an idea of what you want to accomplish, you can stay with gpt-3.5-turbo or another model and try to optimize around its capabilities.You can use the GPT comparison tool that lets you run different models side-by-side to compare outputs, settings, and response times and then download the data into an Excel spreadsheet.DALL·E BetaDALL·E is a AI system that can create realistic images and art from a description in natural language. We currently support the ability, given a prommpt, to create a new image with a certain size, edit an existing image, or create variations of a user provided image.The current DALL·E model available through our API is the 2nd iteration of DALL·E with more realistic, accurate, and 4x greater resolution images than the original model. You can try it through the our Labs interface or via the API.Whisper BetaWhisper is a general-purpose speech recognition model. It is trained on a large dataset of diverse audio and is also a multi-task model that can perform multilingual speech recognition as well as speech translation and language identification. The Whisper v2-large model is currently available through our API with the whisper-1 model name.Currently, there is no difference between the open source version of Whisper and the version available through our API. However, through our API, we offer an optimized inference process which makes running Whisper through our API much faster than doing it through other means. For more technical details on Whisper, you can read the paper.EmbeddingsEmbeddings are a numerical representation of text that can be used to measure the relateness between two pieces of text. Our second generation embedding model, text-embedding-ada-002 is a designed to replace the previous 16 first-generation embedding models at a fraction of the cost. Embeddings are useful for search, clustering, recommendations, anomaly detection, and classification tasks. You can read more about our latest embedding model in the announcement blog post.ModerationThe Moderation models are designed to check whether content complies with OpenAI's usage policies. The models provide classification capabilities that look for content in the following categories: hate, hate/threatening, self-harm, sexual, sexual/minors, violence, and violence/graphic. You can find out more in our moderation guide.Moderation models take in an arbitrary sized input that is automatically broken up to fix the models specific context window.ModelDescriptiontext-moderation-latestMost capable moderation model. Accuracy will be slighlty higher than the stable modeltext-moderation-stableAlmost as capable as the latest model, but slightly older.GPT-3GPT-3 models can understand and generate natural language. These models were superceded by the more powerful GPT-3.5 generation models. However, the original GPT-3 base models (davinci, curie, ada, and babbage) are current the only models that are available to fine-tune.Latest modelDescriptionMax tokensTraining datatext-curie-001Very capable, faster and lower cost than Davinci.2,049 tokensUp to Oct 2019text-babbage-001Capable of straightforward tasks, very fast, and lower cost.2,049 tokensUp to Oct 2019text-ada-001Capable of very simple tasks, usually the fastest model in the GPT-3 series, and lowest cost.2,049 tokensUp to Oct 2019davinciMost capable GPT-3 model. Can do any task the other models can do, often with higher quality.2,049 tokensUp to Oct 2019curieVery capable, but faster and lower cost than Davinci.2,049 tokensUp to Oct 2019babbageCapable of straightforward tasks, very fast, and lower cost.2,049 tokensUp to Oct 2019adaCapable of very simple tasks, usually the fastest model in the GPT-3 series, and lowest cost.2,049 tokensUp to Oct 2019Codex DeprecatedThe Codex models are now deprecated. They were descendants of our GPT-3 models that would understand and generate code. Their training data contains both natural language and billions of lines of public code from GitHub. Learn more.They’re most capable in Python and proficient in over a dozen languages including JavaScript, Go, Perl, PHP, Ruby, Swift, TypeScript, SQL, and even Shell.The following Codex models are now deprecated:Latest modelDescriptionMax tokensTraining datacode-davinci-002Most capable Codex model. Particularly good at translating natural language to code. In addition to completing code, also supports inserting completions within code.8,001 tokensUp to Jun 2021code-davinci-001Earlier version of code-davinci-0028,001 tokensUp to Jun 2021code-cushman-002Almost as capable as Davinci Codex, but slightly faster. This speed advantage may make it preferable for real-time applications.Up to 2,048 tokenscode-cushman-001Earlier version of code-cushman-002Up to 2,048 tokensFor more, visit our guide on working with Codex.",
		"LibrariesPython libraryWe provide a Python library, which you can install as follows:$ pip install openaiOnce installed, you can use the bindings and your secret key to run the following:1\n2\n3\n4\n5\n6\n7\nimport os\nimport openai\n\n# Load your API key from an environment variable or secret management service\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\nresponse = openai.Completion.create(model=\"text-davinci-003\", prompt=\"Say this is a test\", temperature=0, max_tokens=7)The bindings also will install a command-line utility you can use as follows:$ openai api completions.create -m text-davinci-003 -p \"Say this is a test\" -t 0 -M 7 --streamNode.js libraryWe also have a Node.js library, which you can install by running the following command in your Node.js project directory:$ npm install openaiOnce installed, you can use the library and your secret key to run the following:1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nconst { Configuration, OpenAIApi } = require(\"openai\");\nconst configuration = new Configuration({\n  apiKey: process.env.OPENAI_API_KEY,\n});\nconst openai = new OpenAIApi(configuration);\nconst response = await openai.createCompletion({\n  model: \"text-davinci-003\",\n  prompt: \"Say this is a test\",\n  temperature: 0,\n  max_tokens: 7,\n});Community librariesThe libraries below are built and maintained by the broader developer community. If you'd like to add a new library here, please follow the instructions in our help center article on adding community libraries.Please note that OpenAI does not verify the correctness or security of these projects. Use them at your own risk!C# / .NETBetalgo.OpenAI.GPT3 by BetalgoOpenAI-API-dotnet by OkGoDoItOpenAI-DotNet by RageAgainstThePixelC++liboai by D7EADClojureopenai-clojure by wkokCrystalopenai-crystal by sferikDart/Flutteropenai by anasfikDelphiDelphiOpenAI by HemulGMElixiropenai.ex by mgalloGogo-gpt3 by sashabaranovJavaopenai-java by Theo KanningJuliaOpenAI.jl by rory-linehanKotlinopenai-kotlin by Mouaad AallamNode.jsopenai-api by Njerschowopenai-api-node by erlapsogpt-x by ceifagpt3 by poteatgpts by thencc@dalenguyen/openai by dalenguyentectalic/openai by tectalicPHPorhanerday/open-ai by orhanerdaytectalic/openai by tectalicopenai-php clinet by openai-phpPythonchronology by OthersideAIRrgpt3 by ben-aaron188Rubyopenai by nileshtrivediruby-openai by alexrudallRustasync-openai by 64bitfieri by lbkolevScalaopenai-scala-client by cequence-ioSwiftOpenAIKit by dylanshineUnityOpenAi-Api-Unity by hexthedevcom.openai.unity by RageAgainstThePixelUnreal EngineOpenAI-Api-Unreal by KellanM",
		"QuickstartOpenAI has trained cutting-edge language models that are very good at understanding and generating text. Our API provides access to these models and can be used to solve virtually any task that involves processing language.In this quickstart tutorial, you’ll build a simple sample application. Along the way, you’ll learn key concepts and techniques that are fundamental to using the API for any task, including:Content generationSummarizationClassification, categorization, and sentiment analysisData extractionTranslationMany more!IntroductionThe completions endpoint is the core of our API and provides a simple interface that’s extremely flexible and powerful. You input some text as a prompt, and the API will return a text completion that attempts to match whatever instructions or context you gave it.PromptWrite a tagline for an ice cream shop.CompletionWe serve up smiles with every scoop!You can think of this as a very advanced autocomplete — the model processes your text prompt and tries to predict what’s most likely to come next.1Start with an instructionImagine you want to create a pet name generator. Coming up with names from scratch is hard!First, you’ll need a prompt that makes it clear what you want. Let’s start with an instruction. Submit this prompt to generate your first completion.Suggest one name for a horse.‍‍Not bad! Now, try making your instruction more specific.Suggest one name for a black horse.‍‍As you can see, adding a simple adjective to our prompt changes the resulting completion. Designing your prompt is essentially how you “program” the model.2Add some examplesCrafting good instructions is important for getting good results, but sometimes they aren’t enough. Let’s try making your instruction even more complex.Suggest three names for a horse that is a superhero.‍‍This completion isn't quite what we want. These names are pretty generic, and it seems like the model didn't pick up on the horse part of our instruction. Let’s see if we can get it to come up with some more relevant suggestions.In many cases, it’s helpful to both show and tell the model what you want. Adding examples to your prompt can help communicate patterns or nuances. Try submitting this prompt which includes a couple examples.Suggest three names for an animal that is a superhero.\n\nAnimal: Cat\nNames: Captain Sharpclaw, Agent Fluffball, The Incredible Feline\nAnimal: Dog\nNames: Ruff the Protector, Wonder Canine, Sir Barks-a-Lot\nAnimal: Horse\nNames:‍‍Nice! Adding examples of the output we’d expect for a given input helped the model provide the types of names we were looking for.3Adjust your settingsPrompt design isn’t the only tool you have at your disposal. You can also control completions by adjusting your settings. One of the most important settings is called temperature.You may have noticed that if you submitted the same prompt multiple times in the examples above, the model would always return identical or very similar completions. This is because your temperature was set to 0.Try re-submitting the same prompt a few times with temperature set to 1.Suggest three names for an animal that is a superhero.\n\nAnimal: Cat\nNames: Captain Sharpclaw, Agent Fluffball, The Incredible Feline\nAnimal: Dog\nNames: Ruff the Protector, Wonder Canine, Sir Barks-a-Lot\nAnimal: Horse\nNames:‍‍TemperatureSee what happened? When temperature is above 0, submitting the same prompt results in different completions each time.Remember that the model predicts which text is most likely to follow the text preceding it. Temperature is a value between 0 and 1 that essentially lets you control how confident the model should be when making these predictions. Lowering temperature means it will take fewer risks, and completions will be more accurate and deterministic. Increasing temperature will result in more diverse completions.Deep diveUnderstanding tokens and probabilitiesFor your pet name generator, you probably want to be able to generate a lot of name ideas. A moderate temperature of 0.6 should work well.4Build your applicationNode.jsPython (Flask)Now that you’ve found a good prompt and settings, you’re ready to build your pet name generator! We’ve written some code to get you started — follow the instructions below to download the code and run the app.SetupIf you don’t have Node.js installed, install it from here. Then download the code by cloning this repository.git clone https://github.com/openai/openai-quickstart-node.gitIf you prefer not to use git, you can alternatively download the code using this zip file.Add your API keyTo get the app working, you’ll need an API key. You can get one by signing up for an account and returning to this page.Run the appRun the following commands in the project directory to install the dependencies and run the app.npm install\nnpm run devOpen http://localhost:3000 in your browser and you should see the pet name generator!Understand the codeOpen up generate.js in the openai-quickstart-node/pages/api folder. At the bottom, you’ll see the function that generates the prompt that we were using above. Since users will be entering the type of animal their pet is, it dynamically swaps out the part of the prompt that specifies the animal.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfunction generatePrompt(animal) {\n  const capitalizedAnimal = animal[0].toUpperCase() + animal.slice(1).toLowerCase();\n  return `Suggest three names for an animal that is a superhero.\n\nAnimal: Cat\nNames: Captain Sharpclaw, Agent Fluffball, The Incredible Feline\nAnimal: Dog\nNames: Ruff the Protector, Wonder Canine, Sir Barks-a-Lot\nAnimal: ${capitalizedAnimal}\nNames:`;\n}On line 9 in generate.js, you’ll see the code that sends the actual API request. As mentioned above, it uses the completions endpoint with a temperature of 0.6.1\n2\n3\n4\n5\nconst completion = await openai.createCompletion({\n  model: \"text-davinci-003\",\n  prompt: generatePrompt(req.body.animal),\n  temperature: 0.6,\n});And that’s it! You should now have a full understanding of how your (superhero) pet name generator uses the OpenAI API!PricingWe offer a spectrum of models with different capabilities and price points. In this tutorial, we used text-davinci-003. We recommend using this model or gpt-3.5-turbo while experimenting since they will yield the best results. Once you’ve got things working, you can see if the other models can produce the same results with lower latency and costs. Or if you might need to move to a more powerful model like gpt-4.The total number of tokens processed in a single request (both prompt and completion) can’t exceed the model's maximum context length. For most models, this is 4,096 tokens or about 3,000 words. As a rough rule of thumb, 1 token is approximately 4 characters or 0.75 words for English text.Pricing is pay-as-you-go per 1,000 tokens, with $5 in free credit that can be used during your first 3 months. Learn more.ClosingThese concepts and techniques will go a long way in helping you build your own application. That said, this simple example demonstrates just a sliver of what’s possible! The completions endpoint is flexible enough to solve virtually any language processing task, including content generation, summarization, semantic search, topic tagging, sentiment analysis, and so much more.One limitation to keep in mind is that, for most models, a single API request can only process up to 4,096 tokens between your prompt and completion.For more advanced tasks, you might find yourself wishing you could provide more examples or context than you can fit in a single prompt. The fine-tuning API is a great option for more advanced tasks like this. Fine-tuning allows you to provide hundreds or even thousands of examples to customize a model for your specific use case.Next stepsTo get inspired and learn more about designing prompts for different tasks:Read our completion guide.Explore our library of example prompts.Start experimenting in the Playground.Keep our usage policies in mind as you start building.",
		"How to build an AI that can answer questions about your websiteThis tutorial walks through a simple example of crawling a website (in this example, the OpenAI website), turning the crawled pages into embeddings using the Embeddings API, and then creating a basic search functionality that allows a user to ask questions about the embedded information. This is intended to be a starting point for more sophisticated applications that make use of custom knowledge bases.Getting startedSome basic knowledge of Python and GitHub is helpful for this tutorial. Before diving in, make sure to set up an OpenAI API key and walk through the quickstart tutorial. This will give a good intuition on how to use the API to its full potential.Python is used as the main programming language along with the OpenAI, Pandas, transformers, NumPy, and other popular packages. If you run into any issues working through this tutorial, please ask a question on the OpenAI Community Forum.To start with the code, clone the full code for this tutorial on GitHub. Alternatively, follow along and copy each section into a Jupyter notebook and run the code step by step, or just read along. A good way to avoid any issues is to set up a new virtual environment and install the required packages by running the following commands: 1\n2\n3\n4\n5\npython -m venv env\n\nsource env/bin/activate\n\npip install -r requirements.txtSetting up a web crawlerThe primary focus of this tutorial is the OpenAI API so if you prefer, you can skip the context on how to create a web crawler and just download the source code. Otherwise, expand the section below to work through the scraping mechanism implementation.Learn how to build a web crawlerAcquiring data in text form is the first step to use embeddings. This tutorial creates a new set of data by crawling the OpenAI website, a technique that you can also use for your own company or personal website.View source code‍While this crawler is written from scratch, open source packages like Scrapy can also help with these operations.This crawler will start from the root URL passed in at the bottom of the code below, visit each page, find additional links, and visit those pages as well (as long as they have the same root domain). To begin, import the required packages, set up the basic URL, and define a HTMLParser class.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nimport requests\nimport re\nimport urllib.request\nfrom bs4 import BeautifulSoup\nfrom collections import deque\nfrom html.parser import HTMLParser\nfrom urllib.parse import urlparse\nimport os\n\n# Regex pattern to match a URL\nHTTP_URL_PATTERN = r'^http[s]*://.+'\n\ndomain = \"openai.com\" # <- put your domain to be crawled\nfull_url = \"https://openai.com/\" # <- put your domain to be crawled with https or http\n\n# Create a class to parse the HTML and get the hyperlinks\nclass HyperlinkParser(HTMLParser):\n    def __init__(self):\n        super().__init__()\n        # Create a list to store the hyperlinks\n        self.hyperlinks = []\n\n    # Override the HTMLParser's handle_starttag method to get the hyperlinks\n    def handle_starttag(self, tag, attrs):\n        attrs = dict(attrs)\n\n        # If the tag is an anchor tag and it has an href attribute, add the href attribute to the list of hyperlinks\n        if tag == \"a\" and \"href\" in attrs:\n            self.hyperlinks.append(attrs[\"href\"])The next function takes a URL as an argument, opens the URL, and reads the HTML content. Then, it returns all the hyperlinks found on that page.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# Function to get the hyperlinks from a URL\ndef get_hyperlinks(url):\n    \n    # Try to open the URL and read the HTML\n    try:\n        # Open the URL and read the HTML\n        with urllib.request.urlopen(url) as response:\n\n            # If the response is not HTML, return an empty list\n            if not response.info().get('Content-Type').startswith(\"text/html\"):\n                return []\n            \n            # Decode the HTML\n            html = response.read().decode('utf-8')\n    except Exception as e:\n        print(e)\n        return []\n\n    # Create the HTML Parser and then Parse the HTML to get hyperlinks\n    parser = HyperlinkParser()\n    parser.feed(html)\n\n    return parser.hyperlinksThe goal is to crawl through and index only the content that lives under the OpenAI domain. For this purpose, a function that calls the get_hyperlinks function but filters out any URLs that are not part of the specified domain is needed. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# Function to get the hyperlinks from a URL that are within the same domain\ndef get_domain_hyperlinks(local_domain, url):\n    clean_links = []\n    for link in set(get_hyperlinks(url)):\n        clean_link = None\n\n        # If the link is a URL, check if it is within the same domain\n        if re.search(HTTP_URL_PATTERN, link):\n            # Parse the URL and check if the domain is the same\n            url_obj = urlparse(link)\n            if url_obj.netloc == local_domain:\n                clean_link = link\n\n        # If the link is not a URL, check if it is a relative link\n        else:\n            if link.startswith(\"/\"):\n                link = link[1:]\n            elif link.startswith(\"#\") or link.startswith(\"mailto:\"):\n                continue\n            clean_link = \"https://\" + local_domain + \"/\" + link\n\n        if clean_link is not None:\n            if clean_link.endswith(\"/\"):\n                clean_link = clean_link[:-1]\n            clean_links.append(clean_link)\n\n    # Return the list of hyperlinks that are within the same domain\n    return list(set(clean_links))The crawl function is the final step in the web scraping task setup. It keeps track of the visited URLs to avoid repeating the same page, which might be linked across multiple pages on a site. It also extracts the raw text from a page without the HTML tags, and writes the text content into a local .txt file specific to the page.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\ndef crawl(url):\n    # Parse the URL and get the domain\n    local_domain = urlparse(url).netloc\n\n    # Create a queue to store the URLs to crawl\n    queue = deque([url])\n\n    # Create a set to store the URLs that have already been seen (no duplicates)\n    seen = set([url])\n\n    # Create a directory to store the text files\n    if not os.path.exists(\"text/\"):\n            os.mkdir(\"text/\")\n\n    if not os.path.exists(\"text/\"+local_domain+\"/\"):\n            os.mkdir(\"text/\" + local_domain + \"/\")\n\n    # Create a directory to store the csv files\n    if not os.path.exists(\"processed\"):\n            os.mkdir(\"processed\")\n\n    # While the queue is not empty, continue crawling\n    while queue:\n\n        # Get the next URL from the queue\n        url = queue.pop()\n        print(url) # for debugging and to see the progress\n\n        # Save text from the url to a <url>.txt file\n        with open('text/'+local_domain+'/'+url[8:].replace(\"/\", \"_\") + \".txt\", \"w\", encoding=\"UTF-8\") as f:\n\n            # Get the text from the URL using BeautifulSoup\n            soup = BeautifulSoup(requests.get(url).text, \"html.parser\")\n\n            # Get the text but remove the tags\n            text = soup.get_text()\n\n            # If the crawler gets to a page that requires JavaScript, it will stop the crawl\n            if (\"You need to enable JavaScript to run this app.\" in text):\n                print(\"Unable to parse page \" + url + \" due to JavaScript being required\")\n            \n            # Otherwise, write the text to the file in the text directory\n            f.write(text)\n\n        # Get the hyperlinks from the URL and add them to the queue\n        for link in get_domain_hyperlinks(local_domain, url):\n            if link not in seen:\n                queue.append(link)\n                seen.add(link)\n\ncrawl(full_url)The last line of the above example runs the crawler which goes through all the accessible links and turns those pages into text files. This will take a few minutes to run depending on the size and complexity of your site.Collapse‍Building an embeddings indexCSV is a common format for storing embeddings. You can use this format with Python by converting the raw text files (which are in the text directory) into Pandas data frames. Pandas is a popular open source library that helps you work with tabular data (data stored in rows and columns).Blank empty lines can clutter the text files and make them harder to process. A simple function can remove those lines and tidy up the files.1\n2\n3\n4\n5\n6\ndef remove_newlines(serie):\n    serie = serie.str.replace('\\n', ' ')\n    serie = serie.str.replace('\\\\n', ' ')\n    serie = serie.str.replace('  ', ' ')\n    serie = serie.str.replace('  ', ' ')\n    return serieConverting the text to CSV requires looping through the text files in the text directory created earlier. After opening each file, remove the extra spacing and append the modified text to a list. Then, add the text with the new lines removed to an empty Pandas data frame and write the data frame to a CSV file.Extra spacing and new lines can clutter the text and complicate the embeddings process. The code used here helps to remove some of them but you may find 3rd party libraries or other methods useful to get rid of more unnecessary characters.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nimport pandas as pd\n\n# Create a list to store the text files\ntexts=[]\n\n# Get all the text files in the text directory\nfor file in os.listdir(\"text/\" + domain + \"/\"):\n\n    # Open the file and read the text\n    with open(\"text/\" + domain + \"/\" + file, \"r\", encoding=\"UTF-8\") as f:\n        text = f.read()\n\n        # Omit the first 11 lines and the last 4 lines, then replace -, _, and #update with spaces.\n        texts.append((file[11:-4].replace('-',' ').replace('_', ' ').replace('#update',''), text))\n\n# Create a dataframe from the list of texts\ndf = pd.DataFrame(texts, columns = ['fname', 'text'])\n\n# Set the text column to be the raw text with the newlines removed\ndf['text'] = df.fname + \". \" + remove_newlines(df.text)\ndf.to_csv('processed/scraped.csv')\ndf.head()Tokenization is the next step after saving the raw text into a CSV file. This process splits the input text into tokens by breaking down the sentences and words. A visual demonstration of this can be seen by checking out our Tokenizer in the docs.A helpful rule of thumb is that one token generally corresponds to ~4 characters of text for common English text. This translates to roughly ¾ of a word (so 100 tokens ~= 75 words).The API has a limit on the maximum number of input tokens for embeddings. To stay below the limit, the text in the CSV file needs to be broken down into multiple rows. The existing length of each row will be recorded first to identify which rows need to be split.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nimport tiktoken\n\n# Load the cl100k_base tokenizer which is designed to work with the ada-002 model\ntokenizer = tiktoken.get_encoding(\"cl100k_base\")\n\ndf = pd.read_csv('processed/scraped.csv', index_col=0)\ndf.columns = ['title', 'text']\n\n# Tokenize the text and save the number of tokens to a new column\ndf['n_tokens'] = df.text.apply(lambda x: len(tokenizer.encode(x)))\n\n# Visualize the distribution of the number of tokens per row using a histogram\ndf.n_tokens.hist()The newest embeddings model can handle inputs with up to 8191 input tokens so most of the rows would not need any chunking, but this may not be the case for every subpage scraped so the next code chunk will split the longer lines into smaller chunks.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nmax_tokens = 500\n\n# Function to split the text into chunks of a maximum number of tokens\ndef split_into_many(text, max_tokens = max_tokens):\n\n    # Split the text into sentences\n    sentences = text.split('. ')\n\n    # Get the number of tokens for each sentence\n    n_tokens = [len(tokenizer.encode(\" \" + sentence)) for sentence in sentences]\n    \n    chunks = []\n    tokens_so_far = 0\n    chunk = []\n\n    # Loop through the sentences and tokens joined together in a tuple\n    for sentence, token in zip(sentences, n_tokens):\n\n        # If the number of tokens so far plus the number of tokens in the current sentence is greater \n        # than the max number of tokens, then add the chunk to the list of chunks and reset\n        # the chunk and tokens so far\n        if tokens_so_far + token > max_tokens:\n            chunks.append(\". \".join(chunk) + \".\")\n            chunk = []\n            tokens_so_far = 0\n\n        # If the number of tokens in the current sentence is greater than the max number of \n        # tokens, go to the next sentence\n        if token > max_tokens:\n            continue\n\n        # Otherwise, add the sentence to the chunk and add the number of tokens to the total\n        chunk.append(sentence)\n        tokens_so_far += token + 1\n\n    return chunks\n    \n\nshortened = []\n\n# Loop through the dataframe\nfor row in df.iterrows():\n\n    # If the text is None, go to the next row\n    if row[1]['text'] is None:\n        continue\n\n    # If the number of tokens is greater than the max number of tokens, split the text into chunks\n    if row[1]['n_tokens'] > max_tokens:\n        shortened += split_into_many(row[1]['text'])\n    \n    # Otherwise, add the text to the list of shortened texts\n    else:\n        shortened.append( row[1]['text'] )Visualizing the updated histogram again can help to confirm if the rows were successfully split into shortened sections.1\n2\n3\ndf = pd.DataFrame(shortened, columns = ['text'])\ndf['n_tokens'] = df.text.apply(lambda x: len(tokenizer.encode(x)))\ndf.n_tokens.hist()The content is now broken down into smaller chunks and a simple request can be sent to the OpenAI API specifying the use of the new text-embedding-ada-002 model to create the embeddings:1\n2\n3\n4\n5\n6\nimport openai\n\ndf['embeddings'] = df.text.apply(lambda x: openai.Embedding.create(input=x, engine='text-embedding-ada-002')['data'][0]['embedding'])\n\ndf.to_csv('processed/embeddings.csv')\ndf.head()This should take about 3-5 minutes but after you will have your embeddings ready to use! Building a question answer system with your embeddingsThe embeddings are ready and the final step of this process is to create a simple question and answer system. This will take a user's question, create an embedding of it, and compare it with the existing embeddings to retrieve the most relevant text from the scraped website. The text-davinci-003 model will then generate a natural sounding answer based on the retrieved text.Turning the embeddings into a NumPy array is the first step, which will provide more flexibility in how to use it given the many functions available that operate on NumPy arrays. It will also flatten the dimension to 1-D, which is the required format for many subsequent operations.1\n2\n3\n4\n5\n6\n7\nimport numpy as np\nfrom openai.embeddings_utils import distances_from_embeddings\n\ndf=pd.read_csv('processed/embeddings.csv', index_col=0)\ndf['embeddings'] = df['embeddings'].apply(eval).apply(np.array)\n\ndf.head()The question needs to be converted to an embedding with a simple function, now that the data is ready. This is important because the search with embeddings compares the vector of numbers (which was the conversion of the raw text) using cosine distance. The vectors are likely related and might be the answer to the question if they are close in cosine distance. The OpenAI python package has a built in distances_from_embeddings function which is useful here.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\ndef create_context(\n    question, df, max_len=1800, size=\"ada\"\n):\n    \"\"\"\n    Create a context for a question by finding the most similar context from the dataframe\n    \"\"\"\n\n    # Get the embeddings for the question\n    q_embeddings = openai.Embedding.create(input=question, engine='text-embedding-ada-002')['data'][0]['embedding']\n\n    # Get the distances from the embeddings\n    df['distances'] = distances_from_embeddings(q_embeddings, df['embeddings'].values, distance_metric='cosine')\n\n\n    returns = []\n    cur_len = 0\n\n    # Sort by distance and add the text to the context until the context is too long\n    for i, row in df.sort_values('distances', ascending=True).iterrows():\n        \n        # Add the length of the text to the current length\n        cur_len += row['n_tokens'] + 4\n        \n        # If the context is too long, break\n        if cur_len > max_len:\n            break\n        \n        # Else add it to the text that is being returned\n        returns.append(row[\"text\"])\n\n    # Return the context\n    return \"\\n\\n###\\n\\n\".join(returns)The text was broken up into smaller sets of tokens, so looping through in ascending order and continuing to add the text is a critical step to ensure a full answer. The max_len can also be modified to something smaller, if more content than desired is returned.The previous step only retrieved chunks of texts that are semantically related to the question, so they might contain the answer, but there's no guarantee of it. The chance of finding an answer can be further increased by returning the top 5 most likely results.The answering prompt will then try to extract the relevant facts from the retrieved contexts, in order to formulate a coherent answer. If there is no relevant answer, the prompt will return “I don’t know”.A realistic sounding answer to the question can be created with the completion endpoint using text-davinci-003.1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\ndef answer_question(\n    df,\n    model=\"text-davinci-003\",\n    question=\"Am I allowed to publish model outputs to Twitter, without a human review?\",\n    max_len=1800,\n    size=\"ada\",\n    debug=False,\n    max_tokens=150,\n    stop_sequence=None\n):\n    \"\"\"\n    Answer a question based on the most similar context from the dataframe texts\n    \"\"\"\n    context = create_context(\n        question,\n        df,\n        max_len=max_len,\n        size=size,\n    )\n    # If debug, print the raw model response\n    if debug:\n        print(\"Context:\\n\" + context)\n        print(\"\\n\\n\")\n\n    try:\n        # Create a completions using the question and context\n        response = openai.Completion.create(\n            prompt=f\"Answer the question based on the context below, and if the question can't be answered based on the context, say \\\"I don't know\\\"\\n\\nContext: {context}\\n\\n---\\n\\nQuestion: {question}\\nAnswer:\",\n            temperature=0,\n            max_tokens=max_tokens,\n            top_p=1,\n            frequency_penalty=0,\n            presence_penalty=0,\n            stop=stop_sequence,\n            model=model,\n        )\n        return response[\"choices\"][0][\"text\"].strip()\n    except Exception as e:\n        print(e)\n        return \"\"It is done! A working Q/A system that has the knowledge embedded from the OpenAI website is now ready. A few quick tests can be done to see the quality of the output:1\n2\n3\n4\n5\nanswer_question(df, question=\"What day is it?\", debug=False)\n\nanswer_question(df, question=\"What is our newest embeddings model?\")\n\nanswer_question(df, question=\"What is ChatGPT?\")The responses will look something like the following: 1\n2\n3\n4\n5\n\"I don't know.\"\n\n'The newest embeddings model is text-embedding-ada-002.'\n\n'ChatGPT is a model trained to interact in a conversational way. It is able to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests.'If the system is not able to answer a question that is expected, it is worth searching through the raw text files to see if the information that is expected to be known actually ended up being embedded or not. The crawling process that was done initially was setup to skip sites outside the original domain that was provided, so it might not have that knowledge if there was a subdomain setup.Currently, the dataframe is being passed in each time to answer a question. For more production workflows, a vector database solution should be used instead of storing the embeddings in a CSV file, but the current approach is a great option for prototyping.",
		"Code completion DeprecatedLearn how to generate or manipulate code. As of March 2023, the Codex models are now deprecated. Please check out our newer Chat models which are able to do many coding tasks with similar capabilityIntroductionThe Codex model series is a descendant of our GPT-3 series that's been trained on both natural language and billions of lines of code. It's most capable in Python and proficient in over a dozen languages including JavaScript, Go, Perl, PHP, Ruby, Swift, TypeScript, SQL, and even Shell. During this initial limited beta period, Codex usage is free. Learn more.You can use Codex for a variety of tasks including:Turn comments into codeComplete your next line or function in contextBring knowledge to you, such as finding a useful library or API call for an applicationAdd commentsRewrite code for efficiencyTo see Codex in action, check out our Codex JavaScript Sandbox or our other demo videos.Codex JavaScript SandboxThis sample application uses Codex to translate natural language instructions into JavaScript.Try it out‍Watch demo‍QuickstartHere are a few examples of using Codex that can be tested in the Playground.Saying \"Hello\" (Python)\"\"\"\nAsk the user for their name and say \"Hello\"\n\"\"\"Create random names (Python)\"\"\"\n1. Create a list of first names\n2. Create a list of last names\n3. Combine them randomly into a list of 100 full names\n\"\"\"Create a MySQL query (Python)\"\"\"\nTable customers, columns = [CustomerId, FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId]\nCreate a MySQL query for all customers in Texas named Jane\n\"\"\"\nquery =Explaining code (JavaScript)// Function 1\nvar fullNames = [];\nfor (var i = 0; i < 50; i++) {\n  fullNames.push(names[Math.floor(Math.random() * names.length)]\n    + \" \" + lastNames[Math.floor(Math.random() * lastNames.length)]);\n}\n\n// What does Function 1 do?More examplesVisit our examples library to explore more prompts designed for Codex.Best practicesStart with a comment, data or code. You can experiment using one of the Codex models in our playground (styling instructions as comments when needed.)To get Codex to create a useful completion it's helpful to think about what information a programmer would need to perform a task. This could simply be a clear comment or the data needed to write a useful function, like the names of variables or what class a function handles.# Create a function called 'nameImporter' to add a first and last name to the databaseIn this example we tell Codex what to call the function and what task it's going to perform.This approach scales even to the point where you can provide Codex with a comment and an example of a database schema to get it to write useful query requests for various databases.# Table albums, columns = [AlbumId, Title, ArtistId]\n# Table artists, columns = [ArtistId, Name]\n# Table media_types, columns = [MediaTypeId, Name]\n# Table playlists, columns = [PlaylistId, Name]\n# Table playlist_track, columns = [PlaylistId, TrackId]\n# Table tracks, columns = [TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice]\n\n# Create a query for all albums by AdeleWhen you show Codex the database schema it's able to make an informed guess about how to format a query.Specify the language. Codex understands dozens of different programming languages. Many share similar conventions for comments, functions and other programming syntax. By specifying the language and what version in a comment, Codex is better able to provide a completion for what you want. That said, Codex is fairly flexible with style and syntax.# R language\n# Calculate the mean distance between an array of points# Python 3\n# Calculate the mean distance between an array of pointsPrompt Codex with what you want it to do. If you want Codex to create a webpage, placing the first line of code in an HTML document (<!DOCTYPE html>) after your comment tells Codex what it should do next. The same method works for creating a function from a comment (following the comment with a new line starting with func or def).<!-- Create a web page with the title 'Kat Katman attorney at paw' -->\n<!DOCTYPE html>Placing <!DOCTYPE html> after our comment makes it very clear to Codex what we want it to do.# Create a function to count to 100\n\ndef counterIf we start writing the function Codex will understand what it needs to do next.Specifying libraries will help Codex understand what you want. Codex is aware of a large number of libraries, APIs and modules. By telling Codex which ones to use, either from a comment or importing them into your code, Codex will make suggestions based upon them instead of alternatives.<!-- Use A-Frame version 1.2.0 to create a 3D website -->\n<!-- https://aframe.io/releases/1.2.0/aframe.min.js -->By specifying the version you can make sure Codex uses the most current library.Note: Codex can suggest helpful libraries and APIs, but always be sure to do your own research to make sure that they're safe for your application.Comment style can affect code quality. With some languages the style of comments can improve the quality of the output. For example, when working with Python, in some cases using doc strings (comments wrapped in triple quotes) can give higher quality results than using the pound (#) symbol.\"\"\"\nCreate an array of users and email addresses\n\"\"\"Put comments inside of functions can be helpful. Recommended coding standards usually suggest placing the description of a function inside the function. Using this format helps Codex more clearly understand what you want the function to do.def getUserBalance(id):\n    \"\"\"\n    Look up the user in the database ‘UserData' and return their current account balance.\n    \"\"\"Provide examples for more precise results. If you have a particular style or format you need Codex to use, providing examples or demonstrating it in the first part of the request will help Codex more accurately match what you need.\"\"\"\nCreate a list of random animals and species\n\"\"\"\nanimals  = [ {\"name\": \"Chomper\", \"species\": \"Hamster\"}, {\"name\":Lower temperatures give more precise results. Setting the API temperature to 0, or close to zero (such as 0.1 or 0.2) tends to give better results in most cases. Unlike GPT-3, where a higher temperature can provide useful creative and random results, higher temperatures with Codex may give you really random or erratic responses.In cases where you need Codex to provide different potential results, start at zero and then increment upwards by .1 until you find suitable variation.Organize tasks into functions. We can get Codex to write functions by specifying what the function should do in as precise terms as possible in comment. By writing the following comment, Codex creates a Javascript timer function that's triggered when a user presses a button:A simple JavaScript timer// Create a timer that creates an alert in 10 secondsWe can use Codex to perform common tasks with well known libraries like creating a customer with the Stripe API:Create a Stripe customer in Python# Create a Stripe customer from an email addressCreating example data. Testing applications often requires using example data. Because Codgen is a language model that understands how to comprehend and write natural language, you can ask Codex to create data like arrays of made up names, products and other variables./* Create an array of weather temperatures for San Francisco */Asking Codex to perform this task will produce a table like this:var weather = [\n  { month: 'January', high: 58, low: 48 },\n  { month: 'February', high: 61, low: 50 },\n  { month: 'March', high: 64, low: 53 },\n  { month: 'April', high: 67, low: 55 },\n  { month: 'May', high: 70, low: 58 },\n  { month: 'June', high: 73, low: 61 },\n  { month: 'July', high: 76, low: 63 },\n  { month: 'August', high: 77, low: 64 },\n  { month: 'September', high: 76, low: 63 },\n  { month: 'October', high: 73, low: 61 },\n  { month: 'November', high: 68, low: 57 },\n  { month: 'December', high: 64, low: 54 }\n];Compound functions and small applications. We can provide Codex with a comment consisting of a complex request like creating a random name generator or performing tasks with user input and Codex can generate the rest provided there are enough tokens./*\nCreate a list of animals\nCreate a list of cities\nUse the lists to generate stories about what I saw at the zoo in each city\n*/Limit completion size for more precise results or lower latency. Requesting longer completions in Codex can lead to imprecise answers and repetition. Limit the size of the query by reducing max_tokens and setting stop tokens. For instance, add \\n as a stop sequence to limit completions to one line of code. Smaller completions also incur less latency.Use streaming to reduce latency. Large Codex queries can take tens of seconds to complete. To build applications that require lower latency,\nsuch as coding assistants that perform autocompletion, consider using streaming. Responses will be returned before the model finishes generating the entire completion. Applications that need only part of a completion can reduce latency by cutting off a completion either programmatically or by using creative values for stop.Users can combine streaming with duplication to reduce latency by requesting more than one solution from the API, and using the first response returned. Do this by setting n > 1. This approach consumes more token quota, so use carefully (e.g., by using reasonable settings for max_tokens and stop).Use Codex to explain code. Codex's ability to create and understand code allows us to use it to perform tasks like explaining what the code in a file does. One way to accomplish this is by putting a comment after a function that starts with \"This function\" or \"This application is.\" Codex will usually interpret this as the start of an explanation and complete the rest of the text./* Explain what the previous function is doing: ItExplaining an SQL query. In this example we use Codex to explain in a human readable format what an SQL query is doing.SELECT DISTINCT department.name\nFROM department\nJOIN employee ON department.id = employee.department_id\nJOIN salary_payments ON employee.id = salary_payments.employee_id\nWHERE salary_payments.date BETWEEN '2020-06-01' AND '2020-06-30'\nGROUP BY department.name\nHAVING COUNT(employee.id) > 10;\n-- Explanation of the above query in human readable format\n--Writing unit tests. Creating a unit test can be accomplished in Python simply by adding the comment \"Unit test\" and starting a function.# Python 3\ndef sum_numbers(a, b):\n  return a + b\n\n# Unit test\ndefChecking code for errors. By using examples, you can show Codex how to identify errors in code. In some cases no examples are required, however demonstrating the level and detail to provide a description can help Codex understand what to look for and how to explain it. (A check by Codex for errors should not replace careful review by the user. )/* Explain why the previous function doesn't work. */Using source data to write database functions. Just as a human programmer would benefit from understanding the database structure and the column names, Codex can use this data to help you write accurate query requests. In this example we insert the schema for a database and tell Codex what to query the database for.# Table albums, columns = [AlbumId, Title, ArtistId]\n# Table artists, columns = [ArtistId, Name]\n# Table media_types, columns = [MediaTypeId, Name]\n# Table playlists, columns = [PlaylistId, Name]\n# Table playlist_track, columns = [PlaylistId, TrackId]\n# Table tracks, columns = [TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice]\n\n# Create a query for all albums by AdeleConverting between languages. You can get Codex to convert from one language to another by following a simple format where you list the language of the code you want to convert in a comment, followed by the code and then a comment with the language you want it translated into.# Convert this from Python to R\n# Python version\n\n[ Python code ]\n\n# End\n\n# R versionRewriting code for a library or framework. If you want Codex to make a function more efficient, you can provide it with the code to rewrite followed by an instruction on what format to use.// Rewrite this as a React component\nvar input = document.createElement('input');\ninput.setAttribute('type', 'text');\ndocument.body.appendChild(input);\nvar button = document.createElement('button');\nbutton.innerHTML = 'Say Hello';\ndocument.body.appendChild(button);\nbutton.onclick = function() {\n  var name = input.value;\n  var hello = document.createElement('div');\n  hello.innerHTML = 'Hello ' + name;\n  document.body.appendChild(hello);\n};\n\n// React version:Inserting codeThe completions endpoint also supports inserting code within code by providing a suffix prompt in addition to the prefix prompt. This can be used to insert a completion in the middle of a function or file.def get_largest_prime_factor(n):\n    if n < 2:\n        return False\n    def is_prime(n): >  for i in range(2, n): >  if n % i == 0: >  return False >  return True >     largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n    return largestBy providing the model with additional context, it can be much more steerable. However, this is a more constrained and challenging task for the model.Best practicesInserting code is a new feature in beta and you may have to modify the way you use the API for better results. Here are a few best practices:Use max_tokens > 256. The model is better at inserting longer completions. With too small max_tokens, the model may be cut off before it's able to connect to the suffix. Note that you will only be charged for the number of tokens produced even when using larger max_tokens.Prefer finish_reason == \"stop\". When the model reaches a natural stopping point or a user provided stop sequence, it will set finish_reason as \"stop\". This indicates that the model has managed to connect to the suffix well and is a good signal for the quality of a completion. This is especially relevant for choosing between a few completions when using n > 1 or resampling (see the next point).Resample 3-5 times. While almost all completions connect to the prefix, the model may struggle to connect the suffix in harder cases. We find that resampling 3 or 5 times (or using best_of with k=3,5) and picking the samples with \"stop\" as their finish_reason can be an effective way in such cases. While resampling, you would typically want a higher temperatures to increase diversity.Note: if all the returned samples have finish_reason == \"length\", it's likely that max_tokens is too small and model runs out of tokens before it manages to connect the prompt and the suffix naturally. Consider increasing max_tokens before resampling.Editing code BetaThe edits endpoint can be used to edit code, rather than just completing it. You provide some code and an instruction for how to modify it, and the code-davinci-edit-001 model will attempt to edit it accordingly. This is a natural interface for refactoring and tweaking code. During this initial beta period, usage of the edits endpoint is free.ExamplesIteratively build a programWriting code is often an iterative process that requires refining the text along the way. Editing makes it natural to continuously refine the output of the model until the final result is polished. In this example, we use fibonacci as an example of how to iteratively build upon code.1Write a functionInputNo inputInstructionsWrite a function in python that calculates fibonacciOutputdef fibonacci(num):\n    a = 0\n    b = 1\n    if num ==1:\n       print(a)\n    else:\n        print(a)\n        print(b)\n        #the sequence starts with 0,1\n        for i in range(2,num):\n            c = a+b\n            a = b\n            b = c\n            print(c)fibonacci(10)2Refactor itInput    if num ==1:\n        print(a)\n    else:\n        print(a)\n        print(b)\n        #the sequence starts with 0,1\n        for i in range(2,num):\n            c = a+b\n            a = b\n            b = c\n            print(c)fibonacci(10)InstructionsRefactor this function to be recursiveOutputdef fibonacci(num):\n    if num <= 1:\n        return num\n    else:\n        return fib(num-1) + fib(num-2)\nprint(fibonacci(10))3Rename the functionInputdef fibonacci(num):\n    if num <= 1:\n        return num\n    else:\n        return fib(num-1) + fib(num-2)\nprint(fibonacci(10))InstructionsRename the function to fibOutputdef fib(num):    if num <= 1:\n          return num\n      else:        return fib(num-1) + fib(num-2)print(fib(10))4Add documentationInputdef fib(num):\n    if num <= 1:\n        return num\n    else:\n        return fib(num-1) + fib(num-2)\nprint(fib(10))InstructionsAdd documentationOutputdef fib(num):    \"\"\" Print the nth number in the fibonacci sequence \"\"\"    if num <= 1:\n          return num\n      else:\n          return fib(num-1) + fib(num-2)\n  print(fib(10))Best practicesThe edits endpoint is still in alpha, we suggest following these best practices.Consider using an empty prompt! In this case, editing can be used similarly to completion.Be as specific with the instruction as possible.Sometimes, the model cannot find a solution and will result in an error. We suggest rewording your instruction or input.",
		"Model index for researchersOur models are used for both research purposes and developer use cases in production. Researchers often learn about our models from papers that we have published, but there is often not a perfect match between what is available in the OpenAI API and what is published in a paper.The purpose of this page is to help clarify:Some of the differences in the ways that our models are trained, which impacts the comparisons that can be made between models, and various evaluation results.The differences between various model series, such as GPT 3.5 and InstructGPT.Which if any of the models available in the API today match with a model in a paper. In some cases, there might not be a match.Models referred to as \"GPT 3.5\"GPT-3.5 series is a series of models that was trained on a blend of text and code from before Q4 2021. The following models are in the GPT-3.5 series:code-davinci-002 is a base model, so good for pure code-completion taskstext-davinci-002 is an InstructGPT model based on code-davinci-002text-davinci-003 is an improvement on text-davinci-002gpt-3.5-turbo-0301 is an improvement on text-davinci-003, optimized for chatInstructGPT modelsWe offer variants of InstructGPT models trained in 3 different ways:Training MethodModelsSFT  Supervised fine-tuning on human demonstrationsdavinci-instruct-beta1FeedME  Supervised fine-tuning on human-written demonstrations and on model samples rated 7/7 by human labelers on an overall quality scoretext-davinci-001, text-davinci-002, text-curie-001, text-babbage-001PPO  Reinforcement learning with reward models trained from comparisons by humanstext-davinci-003The SFT and PPO models are trained similarly to the ones from the InstructGPT paper. FeedME (short for \"feedback made easy\") models are trained by distilling the best completions from all of our models. Our models generally used the best available datasets at the time of training, and so different engines using the same training methodology might be trained on different data.Models featured in OpenAI ResearchThese are the most proximate models featured in our research papers that are available in the API today. Please note that not all models available in the API correspond to a paper, and even for models that are listed below there may be subtle differences that do not allow for exact replication of the paper. PaperPublishedModel Name in PaperModel Name in APIParameters2[2005.14165] Language Models are Few-Shot Learners22 Jul 2020GPT-3 175Bdavinci175BGPT-3 6.7Bcurie6.7BGPT-3 1Bbabbage1B[2107.03374] Evaluating Large Language Models Trained on Code14 Jul 2021Codex 12Bcode-cushman-001312B[2201.10005] Text and Code Embeddings by Contrastive Pre-Training14 Jan 2022GPT-3 unsupervised cpt-text 175Btext-similarity-davinci-001175BGPT-3 unsupervised cpt-text 6Btext-similarity-curie-0016BGPT-3 unsupervised cpt-text 1.2BNo close matching model on API1.2B[2009.01325] Learning to summarize from human feedback15 Feb 2022GPT-3 6.7B pretrainNo close matching model on API6.7BGPT-3 2.7B pretrainNo close matching model on API2.7BGPT-3 1.3B pretrainNo close matching model on API1.3B[2203.02155] Training language models to follow instructions with human feedback4 Mar 2022InstructGPT-3 175B SFTdavinci-instruct-beta175BInstructGPT-3 175BNo close matching model on API175BInstructGPT-3 6BNo close matching model on API6BInstructGPT-3 1.3BNo close matching model on API1.3B  This model is deprecated and listed here for historical information only.  These parameters are what is indicated in the paper, and in some cases may differ slightly from what is in the API. code-cushman-001 is a stronger, multilingual version of the Codex 12B model in Evaluating Large Language Models Trained on Code.Researcher Access ProgramThere are a number of research directions we are excited to explore with the OpenAI API. If you are interested in the opportunity for subsidized access, please provide us with details about your research use case using this form.In particular, we consider the following to be especially important directions, though you are free to craft your own direction:Alignment: How can we understand what objective, if any, a model is best understood as pursuing? How do we increase the extent to which that objective is aligned with human preferences, such as via prompt design or fine-tuning?Fairness and Representation: How should performance criteria be established for fairness and representation in language models? How can language models be improved in order to effectively support the goals of fairness and representation in specific, deployed contexts?Interdisciplinary Research: How can AI development draw on insights from other disciplines such as philosophy, cognitive science, and sociolinguistics?Interpretability / Transparency: How do these models work, mechanistically? Can we identify what concepts they’re using, or extract latent knowledge from the model, make inferences about the training procedure, or predict surprising future behavior?Misuse Potential: How can systems like the API be misused? What sorts of ‘red teaming’ approaches can we develop to help us and other AI developers think about responsibly deploying technologies like this?Model Exploration: Models like those served by the API have a variety of capabilities which we have yet to explore. We’re excited by investigations in many areas including model limitations, linguistic properties, commonsense reasoning, and potential uses for many other problems.Robustness: Generative models have uneven capability surfaces, with the potential for surprisingly strong and surprisingly weak areas of capability. How robust are large generative models to \"natural\" perturbations in the prompt, such as phrasing the same idea in different ways or with/without typos? Can we predict the kinds of domains and tasks for which large generative models are more likely to be robust (or not robust), and how does this relate to the training data? Are there techniques we can use to predict and mitigate worst-case behavior? How can robustness be measured in the context of few-shot learning (e.g. across variations in prompts)? Can we train models so that they satisfy safety properties with a very high level of reliability, even under adversarial inputs?Please note that due to a high volume of requests, it takes time for us to review these applications (up to 30 business days) and not all research will be prioritized for subsidy. We will only be in touch if your application is selected for subsidy. If you have questions about the Researcher Access Program, you can get in touch with us at researcheraccess@openai.com.",
		"ChatGPT-UserChatGPT-User is used by plugins in ChatGPT. This user-agent will only be used to take direct actions on behalf of ChatGPT users and is not used for crawling the web in any automatic fashion.User agent token: ChatGPT-UserFull user-agent string:  Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko); compatible; ChatGPT-User/1.0; +https://openai.com/botTo allow plugins to access your site you can explicitly add the ChatGPT-User to your site’s robots.txt:User-agent: ChatGPT-User\nDisallow:To allow plugins to access your only parts of your site you can add the ChatGPT-User to your site’s robots.txt like this:1\n2\n3\n4\nUser-agent: ChatGPT-User\nDisallow:\nAllow: /directory-1/\nAllow: /directory-2/To disallow plugins to access your site you can add the ChatGPT-User to your site’s robots.txt:User-agent: ChatGPT-User\nDisallow: /IP egress rangesFor OpenAI's web browsing plugin, calls to websites will be made from the 23.98.142.176/28 IP address block."
	]
}
